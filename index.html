<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CC LEMON 3D</title>
  <style>
    :root {
      --yellow: #f5c000;
      --blue: #1f2fe6;
      --red: #ff0000;
      --accent: #0ae2ff;
      --ink: #0b1720;
    }
    * { box-sizing: border-box; }
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--yellow);
      font-family: "Noto Sans JP", "Hiragino Sans", system-ui, sans-serif;
      color: var(--ink);
    }
    #scene {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    #hud {
      position: fixed;
      inset: 0;
      display: grid;
      grid-template-rows: 1fr auto auto;
      align-items: center;
      justify-items: center;
      pointer-events: none;
      padding: 12px;
    }
    #call {
      font-size: clamp(48px, 10vw, 120px);
      font-weight: 900;
      letter-spacing: 0.12em;
      color: #fff;
      text-shadow: 0 6px 20px rgba(0,0,0,0.25);
      opacity: 0.94;
    }
    #status {
      font-size: 1.1rem;
      font-weight: 700;
      color: rgba(0,0,0,0.7);
      background: rgba(255,255,255,0.72);
      border-radius: 12px;
      padding: 6px 10px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.18);
    }
    #bar {
      display: flex;
      gap: 12px;
      background: rgba(255,255,255,0.72);
      padding: 6px 12px;
      border-radius: 12px;
      font-weight: 800;
      letter-spacing: 0.06em;
      box-shadow: 0 6px 20px rgba(0,0,0,0.18);
    }
    #keys {
      display: flex;
      gap: 8px;
      background: rgba(255,255,255,0.6);
      padding: 4px 10px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 0.95rem;
      box-shadow: 0 4px 14px rgba(0,0,0,0.12);
      color: #123;
    }
    .flash { animation: pulse 0.8s ease-in-out infinite; }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.5; }
      50% { transform: scale(1.06); opacity: 1; }
      100% { transform: scale(1); opacity: 0.5; }
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>
  <div id="start-screen" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:5;">
    <div style="background:#fff8d0;border-radius:16px;padding:18px 22px;box-shadow:0 12px 30px rgba(0,0,0,0.4);display:grid;gap:10px;min-width:240px;text-align:center;font-weight:800;color:#0b1720;">
      <div style="font-size:1.2rem;">モード選択</div>
      <button id="btn-1p" style="padding:10px 12px;font-size:1.05rem;border:none;border-radius:10px;background:#1f2fe6;color:#fff;cursor:pointer;">1人プレイ</button>
      <button id="btn-2p" style="padding:10px 12px;font-size:1.05rem;border:none;border-radius:10px;background:#f01f1f;color:#fff;cursor:pointer;">2人プレイ</button>
      <div style="font-size:0.9rem;font-weight:600;color:#333;">1P: A/S/D ｜ 2P: ;/:/]</div>
    </div>
  </div>
  <div id="hud">
    <div></div>
    <div id="call">Enter</div>
    <div style="display: grid; gap: 6px; justify-items: center;">
      <div id="status"></div>
      <div id="bar"><span id="score-left">左 0</span><span>｜</span><span id="score-right">右 0</span></div>
      <div id="keys">A/S/D ｜ ;/:/]</div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160/build/three.min.js"></script>
  <script>
    // Basic THREE setup
    const canvas = document.getElementById("scene");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.8));

    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#f5c000");
    const camera = new THREE.PerspectiveCamera(48, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 2.5, 10);

    const light = new THREE.DirectionalLight(0xffffff, 1.2);
    light.position.set(4, 8, 6);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.55));

    // Ground plane for reference
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(30, 12),
      new THREE.MeshPhongMaterial({ color: 0xf5c000, side: THREE.DoubleSide })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -2;
    scene.add(ground);

    // Helpers to create players and props
    function makePlayer(color, x) {
      const group = new THREE.Group();
      group.position.set(x, -1.2, 0);
      group.userData = { baseX: x, targetX: x };

      const body = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.65, 1.8, 12, 24),
        new THREE.MeshStandardMaterial({ color, roughness: 0.6, metalness: 0.05 })
      );
      body.position.y = 0.8;
      group.add(body);

      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.7, 32, 32),
        new THREE.MeshStandardMaterial({ color, roughness: 0.45, metalness: 0.08 })
      );
      head.position.set(0, 2.6, 0);
      group.add(head);

      const gun = new THREE.Mesh(
        new THREE.BoxGeometry(0.3, 0.3, 1.6),
        new THREE.MeshPhongMaterial({ color: 0x111111, metalness: 0.2, roughness: 0.6 })
      );
      gun.position.set(x > 0 ? -0.5 : 0.5, 1.2, 0.9);
      gun.rotation.y = x > 0 ? Math.PI / 6 : -Math.PI / 6;
      gun.name = "gun";
      group.add(gun);

      const shield = new THREE.Mesh(
        new THREE.BoxGeometry(1.1, 1.4, 0.2),
        new THREE.MeshPhongMaterial({
          color: 0x0ae2ff,
          transparent: true,
          opacity: 0.8,
          shininess: 120,
          reflectivity: 0.7,
        })
      );
      shield.position.set(x > 0 ? -0.6 : 0.6, 1.2, 1);
      shield.rotation.y = x > 0 ? Math.PI / 6 : -Math.PI / 6;
      shield.visible = false;
      shield.name = "shield";
      group.add(shield);

      const chargeGroup = new THREE.Group();
      chargeGroup.name = "chargeGroup";
      chargeGroup.position.set(0, 3.8, 0);
      group.add(chargeGroup);

      const label = makeLabelSprite("1P");
      label.position.set(0, 4.4, 0);
      label.name = "label";
      group.add(label);

      scene.add(group);
      return group;
    }

    const leftPlayer = makePlayer(0x1f2fe6, -3.4);
    const rightPlayer = makePlayer(0xf01f1f, 3.4);

    // Bullets and particles pool
    const bullets = [];
    const splashes = [];
    const rains = [];
    const guards = [];
    let cpuTimeout = null;
    let nextRoundTimeout = null;
    let celebrateTimer = 0;
    let followTarget = null;

    function spawnBullet(fromLeft, willHit) {
      const geom = new THREE.SphereGeometry(0.2, 24, 24);
      const bullet = new THREE.Mesh(
        geom,
        new THREE.MeshPhongMaterial({ color: 0xf9e463, emissive: 0xc8a400 })
      );
      bullet.scale.set(1, 1, 1.8); // レモン型
      bullet.position.copy(fromLeft ? leftPlayer.position : rightPlayer.position);
      bullet.position.y = 1.2;
      bullet.position.z = 0.2;
      bullet.userData = {
        dir: fromLeft ? 1 : -1,
        life: 2.5,
        willHit,
        target: fromLeft ? rightPlayer : leftPlayer,
        fromLeft,
      };
      scene.add(bullet);
      bullets.push(bullet);
    }

    function spawnSplash(targetPlayer) {
      const base = targetPlayer.position.clone();
      base.y = 1.1;
      for (let i = 0; i < 28; i++) {
        const drop = new THREE.Mesh(
          new THREE.SphereGeometry(0.08 + Math.random() * 0.06, 14, 14),
          new THREE.MeshPhongMaterial({ color: 0xf9e463, emissive: 0xc8a400, roughness: 0.4 })
        );
        drop.position.copy(base);
        drop.userData = {
          vel: new THREE.Vector3(
            (Math.random() - 0.5) * 2.2,
            Math.random() * 2.4,
            (Math.random() - 0.5) * 1.8
          ),
          life: 1.2,
        };
        scene.add(drop);
        splashes.push(drop);
      }
    }

    function spawnChargeRain(player) {
      const base = player.position.clone();
      for (let i = 0; i < 22; i++) {
        const orb = new THREE.Mesh(
          new THREE.SphereGeometry(0.12, 16, 16),
          new THREE.MeshPhongMaterial({ color: 0xf9e463, emissive: 0xc8a400, transparent: true, opacity: 0.9 })
        );
        orb.position.set(
          base.x + (Math.random() - 0.5) * 1.4,
          3 + Math.random() * 2,
          (Math.random() - 0.5) * 1.4
        );
        orb.userData = {
          velY: - (0.8 + Math.random() * 0.8),
          life: 1.6,
        };
        scene.add(orb);
        rains.push(orb);
      }
    }

    function addStain(player) {
      const count = 4 + Math.floor(Math.random() * 4);
      if (!player.userData.stains) player.userData.stains = [];
      for (let i = 0; i < count; i++) {
        const stain = new THREE.Mesh(
          new THREE.SphereGeometry(0.14 + Math.random() * 0.18, 18, 18),
          new THREE.MeshStandardMaterial({ color: 0xf9e463, emissive: 0xc8a400, roughness: 0.5, metalness: 0.05 })
        );
        stain.position.set(
          (Math.random() - 0.5) * 0.9,
          0.5 + Math.random() * 1.6,
          0.35 + Math.random() * 0.5
        );
        stain.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        player.add(stain);
        player.userData.stains.push(stain);
        if (player.userData.stains.length > 18) {
          const old = player.userData.stains.shift();
          player.remove(old);
        }
      }
      cameraKick(0.9);
    }

    function knockBack(player, dir) {
      player.userData.knock = {
        hold: 0.3,
        launchX: dir * 100,
        launchY: 0,
      };
      camDistTarget = 18;
      camFocusTargetX = player.position.x;
      followTarget = player;
      player.userData.flightLife = 2.2;
    }

    function spawnWinBurst(player) {
      const base = player.position.clone();
      base.y = 1.4;
      for (let i = 0; i < 50; i++) {
        const drop = new THREE.Mesh(
          new THREE.SphereGeometry(0.12 + Math.random() * 0.08, 12, 12),
          new THREE.MeshPhongMaterial({ color: 0xfff2a8, emissive: 0xe1c453, transparent: true, opacity: 0.95 })
        );
        drop.position.copy(base);
        drop.userData = {
          vel: new THREE.Vector3(
            (Math.random() - 0.5) * 6,
            Math.random() * 6.5,
            (Math.random() - 0.5) * 6
          ),
          life: 1.6,
        };
        scene.add(drop);
        splashes.push(drop);
      }
    }

    function triggerCelebrate() {
      const champ = state.pendingCelebrate;
      if (!champ) return;
      champ.visible = true;
      champ.userData.celebrate = 2.0;
      spawnWinBurst(champ);
      focusOn(champ.position.x, 1.2, 7.0);
      cameraKick(0.9);
      state.pendingCelebrate = null;
    }

    function resetPlayersPose() {
      const baseY = -1.2;
      [leftPlayer, rightPlayer].forEach((p) => {
        p.position.x = p.userData.baseX;
        p.position.y = baseY;
        p.userData.targetX = p.userData.baseX;
        delete p.userData.kb;
        delete p.userData.knock;
        delete p.userData.celebrate;
        delete p.userData.flightLife;
        p.rotation.set(0, 0, 0);
        p.visible = true;
      });
      followTarget = null;
    }

    function updateChargeOrbs(player, count) {
      const group = player.getObjectByName("chargeGroup");
      if (!group) return;
      while (group.children.length > count) {
        const mesh = group.children.pop();
        group.remove(mesh);
      }
      while (group.children.length < count) {
        const orb = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 18, 18),
          new THREE.MeshStandardMaterial({ color: 0x78ff78, emissive: 0x2fbf2f, roughness: 0.35 })
        );
        const idx = group.children.length;
        orb.position.set((idx - (count - 1) / 2) * 0.5, Math.sin(idx) * 0.05, 0);
        group.add(orb);
      }
      group.children.forEach((orb, idx) => {
        orb.position.x = (idx - (count - 1) / 2) * 0.5;
        orb.position.y = 0.18 + Math.sin(performance.now() * 0.002 + idx) * 0.08;
      });
    }

    function makeLabelTexture(text) {
      const size = 128;
      const fontSize = text.length > 2 ? 50 : 64;
      const canvasTag = document.createElement("canvas");
      canvasTag.width = canvasTag.height = size;
      const ctx = canvasTag.getContext("2d");
      ctx.clearRect(0, 0, size, size);
      ctx.fillStyle = "rgba(0,0,0,0.78)";
      ctx.font = `bold ${fontSize}px 'Noto Sans JP', sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, size / 2, size / 2);
      const texture = new THREE.CanvasTexture(canvasTag);
      texture.needsUpdate = true;
      return texture;
    }

    function makeLabelSprite(text) {
      const texture = makeLabelTexture(text);
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
      const sprite = new THREE.Sprite(material);
      const scale = text.length > 2 ? 1.2 : 1.5;
      sprite.scale.set(scale, scale, 1);
      return sprite;
    }

    // State
    const mapping = {
      left: { a: "charge", s: "gun", d: "guard" },
      right: { ";": "charge", ":": "gun", "]": "guard" },
    };
    const state = {
      scores: { left: 0, right: 0 },
      charges: { left: 0, right: 0 },
      choices: { left: null, right: null },
      roundOpen: false,
      sequenceRunning: false,
      timerId: null,
      winner: null,
      mode: null, // "pvp" or "cpu"
      pendingCelebrate: null,
    };

    const callEl = document.getElementById("call");
    const statusEl = document.getElementById("status");
    const scoreLeft = document.getElementById("score-left");
    const scoreRight = document.getElementById("score-right");
    const startScreen = document.getElementById("start-screen");
    const btn1p = document.getElementById("btn-1p");
    const btn2p = document.getElementById("btn-2p");

    function refreshUI(hidden = true) {
      scoreLeft.textContent = `左 ${state.scores.left}`;
      scoreRight.textContent = `右 ${state.scores.right}`;
      updateChargeOrbs(leftPlayer, state.charges.left);
      updateChargeOrbs(rightPlayer, state.charges.right);
      updateLabels();
      if (hidden) return;
    }

    function updateLabels() {
      const leftLabel = leftPlayer.getObjectByName("label");
      const rightLabel = rightPlayer.getObjectByName("label");
      if (leftLabel) {
        leftLabel.material.map = makeLabelTexture("1P");
        leftLabel.material.needsUpdate = true;
      }
      const rightText = state.mode === "cpu" ? "CPU" : "2P";
      if (rightLabel) {
        rightLabel.material.map = makeLabelTexture(rightText);
        rightLabel.material.needsUpdate = true;
      }
    }

    function startSequence() {
      if (state.roundOpen || state.sequenceRunning || state.winner) return;
      if (!state.mode) return;
      state.sequenceRunning = true;
      state.choices = { left: null, right: null };
      refreshUI(true);
      camFocusTargetX = 0;
      camDistTarget = 9.6;
      statusEl.textContent = "";
      const calls = ["3", "2", "1"];
      callEl.classList.add("flash");
      const step = (idx) => {
        if (idx >= calls.length) {
          callEl.classList.remove("flash");
          state.sequenceRunning = false;
          startRound();
          return;
        }
        callEl.textContent = calls[idx];
        statusEl.textContent = idx === 0 ? "どん！" : idx === 1 ? "どん！" : "どどん！";
        cameraKick();
        setTimeout(() => step(idx + 1), 500);
      };
      step(0);
    }

    function startRound() {
      state.roundOpen = true;
      statusEl.textContent = "";
      callEl.textContent = "入力";
      clearTimeout(state.timerId);
      state.timerId = setTimeout(resolveRound, 3000);
      hideShields();
      if (state.mode === "cpu") scheduleCpuChoice();
    }

    function resolveRound() {
      if (!state.roundOpen) return;
      state.roundOpen = false;
      clearTimeout(state.timerId);
      clearTimeout(cpuTimeout);
      clearTimeout(nextRoundTimeout);
      if (!state.choices.left) state.choices.left = "none";
      if (!state.choices.right) state.choices.right = "none";
      const outcome = judge(state.choices.left, state.choices.right);
      refreshUI(false);
      handleVisuals(outcome.visuals);
      callEl.textContent = outcome.call;
      statusEl.textContent = outcome.detail;
      checkWinner();
      if (!state.winner) {
        const hit = outcome.visuals.hitLeft || outcome.visuals.hitRight;
        if (hit) {
          scheduleResetAfterHit();
        } else {
          nextRoundTimeout = setTimeout(() => startSequence(), 900);
        }
      }
    }

    function judge(left, right) {
      const leftGunAttempt = left === "gun";
      const rightGunAttempt = right === "gun";
      const leftGunReady = leftGunAttempt && state.charges.left > 0;
      const rightGunReady = rightGunAttempt && state.charges.right > 0;

      if (left === "charge") state.charges.left += 1;
      if (right === "charge") state.charges.right += 1;
      if (left === "gun" && state.charges.left > 0) state.charges.left -= 1;
      if (right === "gun" && state.charges.right > 0) state.charges.right -= 1;

      const visuals = {
        left: leftGunReady ? "gun" : left === "guard" ? "shield" : null,
        right: rightGunReady ? "gun" : right === "guard" ? "shield" : null,
        chargeLeft: left === "charge",
        chargeRight: right === "charge",
        hitLeft: false,
        hitRight: false,
      };

      if (leftGunReady && rightGunReady) {
        return { call: "相殺！", detail: "", visuals };
      }
      if (leftGunReady && !rightGunReady) {
        if (right === "guard") return { call: "防がれた", detail: "", visuals };
        state.scores.left += 1;
        visuals.hitRight = true;
        return { call: "左ヒット", detail: "", visuals };
      }
      if (rightGunReady && !leftGunReady) {
        if (left === "guard") return { call: "防いだ", detail: "", visuals };
        state.scores.right += 1;
        visuals.hitLeft = true;
        return { call: "右ヒット", detail: "", visuals };
      }
      if (leftGunAttempt && !leftGunReady) {
        return { call: "左 弾なし", detail: "チャージ不足", visuals };
      }
      if (rightGunAttempt && !rightGunReady) {
        return { call: "右 弾なし", detail: "チャージ不足", visuals };
      }
      if (left === "none" && right === "none") {
        return { call: "静寂", detail: "", visuals };
      }
      return { call: "続行", detail: "", visuals };
    }

    function checkWinner() {
      if (state.scores.left >= 3 || state.scores.right >= 3) {
        state.winner = state.scores.left > state.scores.right ? "左" : "右";
        callEl.textContent = `${state.winner} 勝利`;
        statusEl.textContent = "R";
        state.pendingCelebrate = state.winner === "左" ? leftPlayer : rightPlayer;
      }
    }

    function handleKey(e) {
      const key = e.key;
      if (key.toLowerCase() === "r") {
        resetGame(true);
        return;
      }
      if (!state.roundOpen || state.winner) return;
      if (!state.choices.left && mapping.left[key.toLowerCase()]) {
        state.choices.left = mapping.left[key.toLowerCase()];
        if (state.mode === "cpu" && !state.choices.right) scheduleCpuChoice(true);
      } else if (state.mode !== "cpu" && !state.choices.right && (mapping.right[key] || mapping.right[key.toLowerCase()])) {
        state.choices.right = mapping.right[key] || mapping.right[key.toLowerCase()];
      }
      if (state.choices.left && state.choices.right) resolveRound();
    }

    function resetGame(showStart = false) {
      state.scores = { left: 0, right: 0 };
      state.charges = { left: 0, right: 0 };
      state.choices = { left: null, right: null };
      state.roundOpen = false;
      state.sequenceRunning = false;
      state.winner = null;
      clearTimeout(state.timerId);
      clearTimeout(cpuTimeout);
      clearTimeout(nextRoundTimeout);
      callEl.textContent = "3";
      statusEl.textContent = "3 → 2 → 1 → 3秒入力";
      resetPlayersPose();
      refreshUI(true);
      hideShields();
      if (showStart) {
        state.mode = null;
        camFocusTargetX = 0;
        camDistTarget = 9.6;
        startScreen.style.display = "flex";
      }
    }

    function handleVisuals(visuals) {
      hideShields();
      if (visuals.left === "gun") { spawnBullet(true, visuals.hitRight); focusOn((leftPlayer.position.x + rightPlayer.position.x) * 0.5, 0.5, 8.8); }
      if (visuals.right === "gun") { spawnBullet(false, visuals.hitLeft); focusOn((leftPlayer.position.x + rightPlayer.position.x) * 0.5, 0.5, 8.8); }
      if (visuals.left === "shield") { showShield(leftPlayer, true); focusOn(leftPlayer.position.x, 0.4, 9.0); }
      if (visuals.right === "shield") { showShield(rightPlayer, false); focusOn(rightPlayer.position.x, 0.4, 9.0); }
      if (visuals.chargeLeft) spawnChargeRain(leftPlayer);
      if (visuals.chargeRight) spawnChargeRain(rightPlayer);
      if (visuals.hitLeft) { addStain(leftPlayer); focusOn(leftPlayer.position.x, 0.8, 12.0); }
      if (visuals.hitRight) { addStain(rightPlayer); focusOn(rightPlayer.position.x, 0.8, 12.0); }
      movePlayers(visuals);
    }

    function scheduleResetAfterHit() {
      clearTimeout(nextRoundTimeout);
      camDistTarget = 12.5;
      camFocusTargetX = 0;
      nextRoundTimeout = setTimeout(() => {
        resetPlayersPose();
        camFocusTargetX = 0;
        camDistTarget = 9.6;
        startSequence();
      }, 2000);
    }

    function scheduleCpuChoice(immediate = false) {
      clearTimeout(cpuTimeout);
      const delay = immediate ? 0 : 40 + Math.random() * 80;
      cpuTimeout = setTimeout(() => {
        if (!state.roundOpen || state.winner) return;
        // simple AI: if charge available 70% shoot else charge, occasionally guard
        const hasCharge = state.charges.right > 0;
        let choice = "charge";
        if (Math.random() < 0.2) choice = "guard";
        if (hasCharge && Math.random() < 0.7) choice = "gun";
        state.choices.right = choice;
        if (state.choices.left && state.choices.right) resolveRound();
      }, delay);
    }

    function showShield(player, isLeft) {
      const shield = player.getObjectByName("shield");
      if (!shield) return;
      shield.visible = true;
      setTimeout(() => { shield.visible = false; }, 800);
      if (isLeft) player.rotation.y = 0.12;
      else player.rotation.y = -0.12;
      setTimeout(() => { player.rotation.y = 0; }, 400);
      spawnGuardWave(player);
    }

    function hideShields() {
      leftPlayer.getObjectByName("shield").visible = false;
      rightPlayer.getObjectByName("shield").visible = false;
    }

    function spawnGuardWave(player) {
      const ring = new THREE.Mesh(
        new THREE.RingGeometry(0.6, 0.9, 32),
        new THREE.MeshBasicMaterial({ color: 0x7bf0ff, transparent: true, opacity: 0.8, side: THREE.DoubleSide })
      );
      ring.rotation.x = -Math.PI / 2;
      ring.position.copy(player.position);
      ring.position.y = 1;
      ring.userData = { life: 0.8, scale: 0.8 };
      scene.add(ring);
      guards.push(ring);
    }

    function movePlayers(visuals) {
      leftPlayer.userData.targetX = leftPlayer.userData.baseX;
      rightPlayer.userData.targetX = rightPlayer.userData.baseX;
      if (visuals.left === "gun") leftPlayer.userData.targetX += 0.4;
      if (visuals.right === "gun") rightPlayer.userData.targetX -= 0.4;
      if (visuals.left === "shield") leftPlayer.userData.targetX -= 0.25;
      if (visuals.right === "shield") rightPlayer.userData.targetX += 0.25;
    }

    let camPhase = 0;
    let camShake = 0;
    let timeScale = 1;
    let camFocusX = 0;
    let camFocusTargetX = 0;
    let camDist = 9.6;
    let camDistTarget = 9.6;
    let camOrbit = 0;
    const gravity = 14;
    function cameraKick(power = 0.6) {
      camPhase = power;
      camShake = Math.max(camShake, power * 0.4);
    }

    function focusOn(x, boost = 0.5, dist = 8.8) {
      camFocusTargetX = x;
      camDistTarget = dist;
      cameraKick(boost);
    }

    document.addEventListener("keydown", handleKey);
    btn1p.addEventListener("click", () => startMode("cpu"));
    btn2p.addEventListener("click", () => startMode("pvp"));
    refreshUI(true);

    function startMode(mode) {
      state.mode = mode;
      resetGame(false);
      startScreen.style.display = "none";
      camFocusTargetX = 0;
      camDistTarget = 9.6;
      callEl.textContent = "3";
      statusEl.textContent = "";
      setTimeout(() => startSequence(), 200);
    }

    // Animation loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const raw = clock.getDelta();
      const delta = raw;
      // camera sway
      camPhase = Math.max(0, camPhase - delta);
      camShake = Math.max(0, camShake - delta * 2);
      camOrbit += delta * 0.35;
      const followLerp = followTarget && followTarget.visible ? 8 : 2.5;
      const distLerp = followTarget && followTarget.visible ? 6 : 2.5;
      camFocusX = THREE.MathUtils.lerp(camFocusX, camFocusTargetX, delta * followLerp);
      camDist = THREE.MathUtils.lerp(camDist, camDistTarget, delta * distLerp);
      const sway = Math.sin(performance.now() * 0.0006) * 0.6;
      const shakeX = (Math.random() - 0.5) * camShake;
      const shakeY = (Math.random() - 0.5) * camShake;
      const focusX = camFocusX;
      const target = new THREE.Vector3(focusX, 1.4, 0);
      camera.position.x = focusX + sway + Math.sin(camOrbit) * 0.7 + shakeX;
      camera.position.y = 2.4 + Math.sin(camOrbit * 0.8) * 0.15 + camPhase * 0.4 + shakeY;
      camera.position.z = camDist - camPhase * 0.6 + Math.cos(camOrbit) * 0.6;
      camera.lookAt(target);

      // player move lerp / knockback / celebrate
      let flightActive = false;
      [leftPlayer, rightPlayer].forEach((p) => {
        const baseY = -1.2;
        if (p.userData.celebrate && p.userData.celebrate > 0) {
          p.userData.celebrate -= raw;
          const t = performance.now() * 0.002;
          p.position.x = THREE.MathUtils.lerp(p.position.x, p.userData.baseX, delta * 2.5);
          p.position.y = baseY + 0.6 + Math.sin(t * 6) * 0.3;
          p.rotation.y = Math.sin(t * 6) * 0.5;
        } else if (p.userData.knock && p.userData.knock.hold > 0) {
          p.userData.knock.hold -= raw;
          const shake = 0.9;
          const t = performance.now() * 0.001;
          const freq = 60; // 60Hz振動
          const wave = Math.sin(2 * Math.PI * freq * t);
          const wave2 = Math.sin(2 * Math.PI * freq * t + Math.PI / 3);
          p.position.x = p.userData.targetX + wave * shake * 1.0;
          p.position.y = baseY + 1.4 + wave2 * shake;
          if (p.userData.knock.hold <= 0) {
            p.userData.kb = p.userData.kb || { x: 0, y: 0 };
            p.userData.kb.x += p.userData.knock.launchX;
            p.userData.kb.y += p.userData.knock.launchY;
            delete p.userData.knock;
          }
        } else if (p.userData.kb) {
          p.userData.kb.y -= gravity * delta;
          p.position.x += p.userData.kb.x * delta;
          p.position.y += p.userData.kb.y * delta;
          p.userData.kb.x = THREE.MathUtils.lerp(p.userData.kb.x, 0, delta * 0.6);
          if (p.position.y <= baseY) {
            p.position.y = baseY;
            p.userData.kb.y = 0;
          }
          if (p.userData.flightLife !== undefined) {
            p.userData.flightLife -= delta;
            flightActive = true;
            if (p.userData.flightLife <= 0 && p.visible) {
              spawnSplash(p);
              p.visible = false;
              p.userData.kb = null;
              p.userData.knock = null;
              p.userData.flightLife = null;
              followTarget = null;
              if (state.pendingCelebrate) triggerCelebrate();
            }
          }
        } else {
          p.rotation.y = THREE.MathUtils.lerp(p.rotation.y, 0, delta * 3);
          p.position.x = THREE.MathUtils.lerp(p.position.x, p.userData.targetX, delta * 3);
          p.position.y = THREE.MathUtils.lerp(p.position.y, baseY, delta * 3);
        }
      });
      if (followTarget && followTarget.visible) {
        camFocusTargetX = followTarget.position.x;
        camDistTarget = 14;
      } else if (state.pendingCelebrate && !flightActive) {
        triggerCelebrate();
      }
      updateChargeOrbs(leftPlayer, state.charges.left);
      updateChargeOrbs(rightPlayer, state.charges.right);

      // bullet vs bullet
      for (let i = 0; i < bullets.length; i++) {
        for (let j = i + 1; j < bullets.length; j++) {
          const a = bullets[i], b = bullets[j];
          if (!a || !b) continue;
          if (a.userData.fromLeft === b.userData.fromLeft) continue;
          if (a.position.distanceTo(b.position) < 0.45) {
            scene.remove(a); scene.remove(b);
            bullets.splice(j, 1); bullets.splice(i, 1);
            i = -1; break;
          }
        }
      }

      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.position.x += b.userData.dir * delta * 8;
        b.userData.life -= delta;
        const target = b.userData.target;
        if (target) {
          const targetPos = target.position.clone();
          targetPos.y = 1.1;
          targetPos.z = 0;
          const dist = b.position.distanceTo(targetPos);
          if (dist <= 0.55) {
            if (b.userData.willHit) {
              spawnSplash(target);
              addStain(target);
              knockBack(target, b.userData.dir);
            }
            scene.remove(b);
            bullets.splice(i, 1);
            continue;
          }
        }
        if (b.userData.life <= 0) {
          scene.remove(b);
          bullets.splice(i, 1);
        }
      }

      for (let i = splashes.length - 1; i >= 0; i--) {
        const p = splashes[i];
        p.position.add(p.userData.vel.clone().multiplyScalar(delta));
        p.userData.vel.y -= delta * 3.2;
        p.userData.life -= delta;
        if (p.userData.life <= 0) {
          scene.remove(p);
          splashes.splice(i, 1);
        }
      }

      for (let i = rains.length - 1; i >= 0; i--) {
        const r = rains[i];
        r.position.y += r.userData.velY * delta * 4;
        r.userData.life -= delta;
        if (r.position.y <= -1.2) r.userData.life = Math.min(r.userData.life, 0.1);
        if (r.userData.life <= 0) {
          scene.remove(r);
          rains.splice(i, 1);
        }
      }

      for (let i = guards.length - 1; i >= 0; i--) {
        const g = guards[i];
        g.userData.life -= delta;
        g.userData.scale += delta * 2;
        g.scale.setScalar(g.userData.scale);
        g.material.opacity = Math.max(0, g.userData.life);
        if (g.userData.life <= 0) {
          scene.remove(g);
          guards.splice(i, 1);
        }
      }
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
