<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CC LEMON 3D</title>
  <style>
    :root {
      --yellow: #f5c000;
      --blue: #0015ff;
      --red: #ff0000;
      --accent: #0ae2ff;
      --ink: #0b1720;
    }
    * { box-sizing: border-box; }
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--yellow);
      font-family: "Noto Sans JP", "Hiragino Sans", system-ui, sans-serif;
      color: var(--ink);
    }
    #scene {
      width: 100vw;
      height: 100vh;
      display: block;
    }
    #hud {
      position: fixed;
      inset: 0;
      display: grid;
      grid-template-rows: 1fr auto auto;
      align-items: center;
      justify-items: center;
      pointer-events: none;
      padding: 12px;
    }
    #call {
      font-size: clamp(48px, 10vw, 120px);
      font-weight: 900;
      letter-spacing: 0.12em;
      color: #fff;
      text-shadow: 0 6px 20px rgba(0,0,0,0.25);
      opacity: 0.94;
    }
    #status {
      font-size: 1.1rem;
      font-weight: 700;
      color: rgba(0,0,0,0.7);
      background: rgba(255,255,255,0.72);
      border-radius: 12px;
      padding: 6px 10px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.18);
    }
    #bar {
      display: flex;
      gap: 12px;
      background: rgba(255,255,255,0.72);
      padding: 6px 12px;
      border-radius: 12px;
      font-weight: 800;
      letter-spacing: 0.06em;
      box-shadow: 0 6px 20px rgba(0,0,0,0.18);
    }
    #keys {
      display: flex;
      gap: 8px;
      background: rgba(255,255,255,0.6);
      padding: 4px 10px;
      border-radius: 10px;
      font-weight: 700;
      font-size: 0.95rem;
      box-shadow: 0 4px 14px rgba(0,0,0,0.12);
      color: #123;
      pointer-events: auto; /* allow clicking buttons inside HUD */
    }
    .flash { animation: pulse 0.8s ease-in-out infinite; }
    @keyframes pulse {
      0% { transform: scale(1); opacity: 0.5; }
      50% { transform: scale(1.06); opacity: 1; }
      100% { transform: scale(1); opacity: 0.5; }
    }
    #settings-button {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 36px;
      height: 36px;
      border: none;
      border-radius: 50%;
      background: rgba(0,0,0,0.1);
      cursor: pointer;
      display: grid;
      place-items: center;
      font-size: 18px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.2);
    }
    #settings-panel {
      position: absolute;
      top: 52px;
      right: 10px;
      background: #fff8d0;
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 12px 24px rgba(0,0,0,0.25);
      display: none;
      min-width: 180px;
      font-weight: 700;
      color: #0b1720;
      gap: 8px;
    }
    #settings-overlay {
      position: fixed;
      inset: 0;
      z-index: 8;
      display: none;
      place-items: center;
      background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.45), rgba(255,255,255,0.2)), rgba(0,0,0,0.4);
      backdrop-filter: blur(6px);
      padding: 16px;
    }
    .settings-card {
      width: min(520px, 90vw);
      background: #fff9d8;
      border-radius: 18px;
      box-shadow: 0 16px 40px rgba(0,0,0,0.35);
      padding: 18px 18px 16px;
      color: #0b1720;
      display: grid;
      gap: 14px;
      border: 2px solid rgba(0,0,0,0.08);
    }
    .settings-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .settings-head h2 {
      margin: 0;
      font-size: 1.35rem;
      letter-spacing: 0.04em;
    }
    .pill-group {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }
    .pill {
      border: 2px solid #0b1720;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 800;
      font-size: 1rem;
      cursor: pointer;
      background: #fff;
      color: #0b1720;
      transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease, color 0.12s ease;
    }
    .pill.active {
      background: #0b1720;
      color: #fff9d8;
      box-shadow: 0 10px 24px rgba(0,0,0,0.26);
      transform: translateY(-1px);
    }
    .settings-row {
      background: rgba(255,255,255,0.7);
      border-radius: 14px;
      padding: 12px;
      border: 1px solid rgba(0,0,0,0.05);
      display: grid;
      gap: 8px;
    }
    .settings-row h3 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: 0.02em;
    }
    .settings-note {
      margin: 0;
      color: rgba(11, 23, 32, 0.7);
      font-size: 0.92rem;
      line-height: 1.5;
    }
    .toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 800;
      font-size: 0.98rem;
    }
    .toggle input {
      width: 18px;
      height: 18px;
      cursor: pointer;
      accent-color: #1f2fe6;
    }
    .settings-actions {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }
    .settings-close {
      border: none;
      border-radius: 10px;
      padding: 10px 14px;
      font-weight: 800;
      cursor: pointer;
      background: #1f2fe6;
      color: #fff;
      box-shadow: 0 10px 20px rgba(0,0,0,0.25);
    }
    #settings-button {
      z-index: 7;
      background: rgba(0,0,0,0.72);
      color: #fff;
    }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: rgba(0,0,0,0.08);
      border-radius: 999px;
      font-size: 0.9rem;
      font-weight: 700;
    }
    #hand-indicators {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 6;
    }
    #shield-meters {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 6;
    }
    .shield-meter {
      position: absolute;
      width: 64px;
      height: 64px;
      transform: translate(-50%, -120%);
      border-radius: 50%;
      background:
        conic-gradient(#7bf0ff calc(var(--pct, 1) * 100%), rgba(0,0,0,0.08) 0);
      box-shadow:
        0 8px 18px rgba(0,0,0,0.35),
        0 4px 10px rgba(123,240,255,0.35);
      display: grid;
      place-items: center;
      opacity: 0.9;
    }
    .shield-meter.locked {
      background: repeating-conic-gradient(from 45deg, rgba(123,240,255,0.4) 0 15deg, rgba(0,0,0,0.08) 15deg 30deg);
      box-shadow:
        0 8px 18px rgba(0,0,0,0.35),
        0 4px 10px rgba(123,240,255,0.35);
      opacity: 0.75;
    }
    .shield-meter .label {
      width: 100%;
      text-align: center;
      font-size: 0.75rem;
      font-weight: 900;
      color: #fff;
      text-shadow:
        0 1px 2px rgba(0,0,0,0.6),
        0 0 10px rgba(0,0,0,0.35);
      line-height: 1.1;
    }
    .bottle-wrap {
      justify-self: center;
      position: relative;
      width: 82px;
      height: 200px;
      filter: drop-shadow(0 12px 18px rgba(0,0,0,0.35));
    }
    .bottle {
      position: absolute;
      inset: 0;
      border-radius: 24px 24px 18px 18px;
      background: linear-gradient(180deg, rgba(255,255,255,0.8), rgba(255,255,255,0.2));
      border: 2px solid rgba(0,0,0,0.12);
      overflow: hidden;
    }
    .bottle::after {
      content: "";
      position: absolute;
      inset: 4px;
      border-radius: 18px 18px 14px 14px;
      background: rgba(255,255,255,0.25);
      z-index: 2;
      pointer-events: none;
    }
    .juice {
      position: absolute;
      left: 4px;
      right: 4px;
      bottom: 4px;
      height: calc(var(--juice, 1) * 100%);
      background: linear-gradient(180deg, #ffd94c, #f9a400);
      border-radius: 14px 14px 12px 12px;
      box-shadow:
        inset 0 2px 8px rgba(255,255,255,0.45),
        inset 0 -4px 10px rgba(0,0,0,0.15);
      transition: height 0.25s ease, background 0.2s ease;
    }
    .juice.low {
      background: linear-gradient(180deg, #ff9c6c, #f05c1f);
      box-shadow:
        inset 0 2px 8px rgba(255,255,255,0.45),
        inset 0 -4px 10px rgba(0,0,0,0.25);
    }
    .bottle-label {
      position: absolute;
      bottom: 10px;
      left: 0;
      right: 0;
      text-align: center;
      font-weight: 900;
      font-size: 0.9rem;
      color: #0b1720;
      text-shadow: 0 1px 3px rgba(255,255,255,0.8);
      z-index: 3;
    }
    .red-x {
      position: absolute;
      color: #ff2222;
      font-size: 72px;
      font-weight: 900;
      transform: translate(-50%, -50%);
      text-shadow: 0 0 16px rgba(255,0,0,0.6);
      opacity: 0.9;
    }
    #bottles { display: none; }
    #boost-bar {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 8;
    }
    #shield-meters { }
    .boost-pill {
      position: absolute;
      width: 16px;
      height: 120px;
      transform: translate(-50%, -50%);
      border-radius: 10px;
      background: rgba(0,0,0,0.35);
      overflow: hidden;
      box-shadow: 0 8px 18px rgba(0,0,0,0.35);
    }
    .boost-fill {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 0%;
      background: linear-gradient(180deg, #7bf0ff, #0ae2ff);
      box-shadow: 0 0 12px rgba(10,226,255,0.6);
      transition: height 0.2s ease;
    }
    .boost-pill.ready .boost-fill {
      animation: pulse 1s ease-in-out infinite;
    }
    .call-pop {
      animation: call-pop 0.5s ease-out;
    }
    @keyframes call-pop {
      0% { transform: scale(0.6); opacity: 0; }
      40% { transform: scale(1.2); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    .score-flash {
      animation: score-flash 0.4s ease-out;
    }
    @keyframes score-flash {
      0% { transform: scale(1.2); color: #fff; text-shadow: 0 0 14px rgba(255,255,255,0.9); }
      100% { transform: scale(1); color: inherit; text-shadow: none; }
    }
    .hand-line {
      position: absolute;
      width: 120px;
      height: 4px;
      background: rgba(0, 255, 0, 0.75);
      border-radius: 6px;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.7);
      transform: translate(-50%, -50%);
      display: none;
    }
    #fx-layer {
      position: fixed;
      inset: 0;
      z-index: 4;
      pointer-events: none;
      overflow: hidden;
      mix-blend-mode: screen;
    }
    .fx-burst {
      position: absolute;
      width: 220px;
      height: 220px;
      transform: translate(-50%, -50%) scale(0.6);
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(250,226,80,0.85) 35%, rgba(255,95,63,0.2) 70%, rgba(255,95,63,0) 90%);
      filter: drop-shadow(0 0 18px rgba(255,255,255,0.6));
      animation: fx-pop 0.48s ease-out forwards;
    }
    .fx-speed {
      position: absolute;
      width: 120vw;
      height: 12px;
      background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.8) 25%, rgba(255,255,255,0) 60%);
      opacity: 0.85;
      --rot: 0deg;
      transform-origin: left center;
      animation: fx-speed 0.42s cubic-bezier(0.16, 0.86, 0.4, 1) forwards;
      filter: drop-shadow(0 0 8px rgba(255,255,255,0.8));
    }
    .fx-flash {
      position: absolute;
      inset: -10%;
      background: radial-gradient(circle at 50% 50%, rgba(255,255,255,0.5), rgba(255,255,255,0));
      animation: fx-flash 0.28s ease-out forwards;
    }
    .fx-impact {
      position: absolute;
      width: 260px;
      height: 200px;
      transform: translate(-50%, -50%) scale(0.46);
      background: #ff9c1f;
      clip-path: polygon(
        50% 0%,
        57% 6%,
        66% 3%,
        72% 10%,
        82% 6%,
        86% 14%,
        94% 12%,
        90% 22%,
        98% 26%,
        90% 34%,
        100% 42%,
        88% 46%,
        96% 54%,
        86% 52%,
        92% 62%,
        82% 60%,
        84% 70%,
        72% 66%,
        70% 82%,
        60% 76%,
        50% 94%,
        40% 76%,
        30% 82%,
        28% 66%,
        16% 70%,
        18% 60%,
        8% 62%,
        14% 52%,
        4% 54%,
        12% 46%,
        0% 42%,
        10% 34%,
        2% 26%,
        10% 22%,
        6% 12%,
        14% 14%,
        18% 6%,
        28% 10%,
        34% 3%,
        43% 6%
      );
      box-shadow: 0 0 16px rgba(255, 156, 31, 0.7);
      animation: fx-impact 0.3s ease-out forwards;
    }
    @keyframes fx-pop {
      0% { transform: translate(-50%, -50%) scale(0.4) rotate(0deg); opacity: 1; }
      70% { transform: translate(-50%, -50%) scale(1.1) rotate(20deg); }
      100% { transform: translate(-50%, -50%) scale(1.2) rotate(32deg); opacity: 0; }
    }
    @keyframes fx-speed {
      0% { transform: rotate(var(--rot)) translate(-20%, -50%) scaleX(0.2); opacity: 1; }
      60% { opacity: 1; }
      100% { transform: rotate(var(--rot)) translate(10%, -50%) scaleX(1.1); opacity: 0; }
    }
    @keyframes fx-flash {
      0% { opacity: 0.95; }
      100% { opacity: 0; }
    }
    @keyframes fx-impact {
      0% { transform: translate(-50%, -50%) scale(0.34); opacity: 1; }
      70% { transform: translate(-50%, -50%) scale(1.02); opacity: 1; }
      100% { transform: translate(-50%, -50%) scale(1.16); opacity: 0; }
    }
  </style>
</head>
<body>
  <canvas id="scene"></canvas>
  <video id="cam" playsinline style="display:none;"></video>
  <canvas id="debug-canvas" width="640" height="480" style="position:fixed;inset:0;width:100vw;height:100vh;z-index:6;pointer-events:none;"></canvas>
  <div id="debug" style="position:fixed;top:10px;left:10px;background:rgba(0,0,0,0.65);color:#fff;padding:8px 10px;border-radius:8px;font-size:12px;font-family:monospace;display:none;z-index:6;pointer-events:none;line-height:1.4;"></div>
  <div id="hand-indicators">
    <div class="hand-line" id="line-left"></div>
    <div class="hand-line" id="line-right"></div>
  </div>
  <div id="shield-meters">
    <div class="shield-meter" id="shield-meter-left">
      <div class="label"></div>
    </div>
    <div class="shield-meter" id="shield-meter-right">
      <div class="label"></div>
    </div>
  </div>
  <div id="bottles">
    <div class="bottle-wrap">
      <div class="bottle">
        <div class="juice" id="juice-left"></div>
        <div class="bottle-label">1P</div>
      </div>
    </div>
    <div class="bottle-wrap">
      <div class="bottle">
        <div class="juice" id="juice-right"></div>
        <div class="bottle-label">2P/CPU</div>
      </div>
    </div>
  </div>
  <div id="boost-bar">
    <div class="boost-pill" id="boost-pill-left"><div class="boost-fill" id="boost-fill-left"></div></div>
    <div class="boost-pill" id="boost-pill-right"><div class="boost-fill" id="boost-fill-right"></div></div>
  </div>
  <div id="fx-layer"></div>
  <div id="input-toggle" style="position:fixed;top:12px;right:12px;z-index:7;background:rgba(0,0,0,0.65);color:#fff;padding:8px 12px;border-radius:12px;font-weight:800;font-size:0.95rem;display:flex;align-items:center;gap:10px;box-shadow:0 8px 20px rgba(0,0,0,0.3);">
    <span>ÂÖ•Âäõ</span>
    <button id="btn-input" style="padding:6px 10px;border:none;border-radius:10px;font-weight:800;cursor:pointer;background:#fff;color:#0b1720;">„Ç≠„Éº</button>
  </div>
  <div id="lock-x-layer" style="position:fixed;inset:0;pointer-events:none;z-index:8;"></div>
  <button id="settings-button" aria-label="Ë®≠ÂÆö" title="Ë®≠ÂÆö" style="position:fixed;bottom:14px;right:14px;z-index:7;">‚öô</button>
  <div id="start-screen" style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:5;">
    <button id="btn-settings" aria-label="Ë®≠ÂÆö" style="position:absolute;top:14px;right:14px;border:none;background:#fff8d0;color:#0b1720;font-size:18px;width:40px;height:40px;border-radius:12px;box-shadow:0 8px 18px rgba(0,0,0,0.3);cursor:pointer;display:grid;place-items:center;font-weight:900;">‚öô</button>
    <div style="background:#fff8d0;border-radius:16px;padding:18px 22px;box-shadow:0 12px 30px rgba(0,0,0,0.4);display:grid;gap:10px;min-width:260px;text-align:center;font-weight:800;color:#0b1720;position:relative;">
      <div style="font-size:1.2rem;">„É¢„Éº„ÉâÈÅ∏Êäû</div>
      <button id="btn-1p" style="padding:10px 12px;font-size:1.05rem;border:none;border-radius:10px;background:#1f2fe6;color:#fff;cursor:pointer;">1‰∫∫„Éó„É¨„Ç§</button>
      <button id="btn-2p" style="padding:10px 12px;font-size:1.05rem;border:none;border-radius:10px;background:#f01f1f;color:#fff;cursor:pointer;">2‰∫∫„Éó„É¨„Ç§</button>
      <div id="cpu-difficulty" style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap;font-size:0.9rem;">
        <span style="font-weight:700;">CPU:</span>
        <button class="pill" data-cpu="normal" style="padding:6px 10px;border:none;border-radius:10px;background:#fff;color:#0b1720;cursor:pointer;font-weight:800;border:2px solid #0b1720;">„Åµ„Å§„ÅÜ</button>
        <button class="pill" data-cpu="smart" style="padding:6px 10px;border:none;border-radius:10px;background:#fff;color:#0b1720;cursor:pointer;font-weight:800;border:2px solid #0b1720;">„ÅÇ„Åü„Åæ„ÅÑ„ÅÑ</button>
        <button class="pill" data-cpu="ultra" style="padding:6px 10px;border:none;border-radius:10px;background:#fff;color:#0b1720;cursor:pointer;font-weight:800;border:2px solid #0b1720;">Ë∂Ö„ÅÇ„Åü„Åæ„ÅÑ„ÅÑ</button>
      </div>
      <div style="display:grid;gap:6px;font-size:0.9rem;">
        <div style="font-weight:700;">È†≠Ë£ÖÂÇô</div>
        <div style="display:grid;gap:6px;">
          <div style="display:flex;justify-content:space-between;gap:8px;align-items:center;">
            <span style="font-weight:700;">Â∑¶</span>
            <div style="display:flex;gap:6px;align-items:center;">
              <button class="pill pill-head" data-head-side="left" data-dir="-1" style="padding:6px 10px;border:2px solid #0b1720;border-radius:10px;font-weight:800;background:#fff;">‚óÄ</button>
              <span id="head-left-label" style="min-width:120px;text-align:center;font-weight:800;">„Å™„Åó</span>
              <button class="pill pill-head" data-head-side="left" data-dir="1" style="padding:6px 10px;border:2px solid #0b1720;border-radius:10px;font-weight:800;background:#fff;">‚ñ∂</button>
            </div>
          </div>
          <div style="display:flex;justify-content:space-between;gap:8px;align-items:center;">
            <span style="font-weight:700;">Âè≥</span>
            <div style="display:flex;gap:6px;align-items:center;">
              <button class="pill pill-head" data-head-side="right" data-dir="-1" style="padding:6px 10px;border:2px solid #0b1720;border-radius:10px;font-weight:800;background:#fff;">‚óÄ</button>
              <span id="head-right-label" style="min-width:120px;text-align:center;font-weight:800;">„Å™„Åó</span>
              <button class="pill pill-head" data-head-side="right" data-dir="1" style="padding:6px 10px;border:2px solid #0b1720;border-radius:10px;font-weight:800;background:#fff;">‚ñ∂</button>
            </div>
          </div>
        </div>
      </div>
      <div style="font-size:0.9rem;font-weight:600;color:#333;">1P: A/S/D ÔΩú 2P: ;/:/]</div>
      <div id="control-mode" style="font-size:0.9rem;font-weight:700;color:#0b1720;background:#fff2a0;border-radius:10px;padding:8px;">Êìç‰Ωú: <span id="control-mode-label"></span></div>
    </div>
  </div>
  <div id="settings-overlay" aria-hidden="true">
    <div class="settings-card">
      <div class="settings-head">
        <h2>Ë®≠ÂÆö</h2>
        <span class="chip">„Ç´„É°„É©„ÅØÊâãÂÖ•Âäõ„Åß‰ΩøÁî®</span>
      </div>
      <div class="settings-row">
        <h3>1P„ÅÆÂÖ•ÂäõÊñπÊ≥ï</h3>
        <div class="pill-group">
          <button class="pill" data-input-mode="keyboard">„Ç≠„Éº„Éú„Éº„Éâ</button>
          <button class="pill" data-input-mode="hand">„Éè„É≥„Éâ„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞</button>
        </div>
        <p class="settings-note">„Éè„É≥„Éâ„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞„Å´„Åô„Çã„Å®Â∑¶Êâã„ÅßÊìç‰Ωú„Åß„Åç„Åæ„Åô„ÄÇ„Ç´„É°„É©„ÅÆË®±ÂèØ„ÇíÊ±Ç„ÇÅ„Çâ„Çå„Åæ„Åô„ÄÇ</p>
      </div>
      <div class="settings-row">
        <h3>Ë°®Á§∫</h3>
        <label class="toggle"><input type="checkbox" id="chk-hand-lines" checked /> Êâã‰ΩçÁΩÆ„É©„Ç§„É≥„ÇíË°®Á§∫</label>
        <label class="toggle"><input type="checkbox" id="chk-debug" /> „Éá„Éê„ÉÉ„Ç∞ÊÉÖÂ†±„ÇíË°®Á§∫ÔºàF3„Å®Âêå„ÅòÔºâ</label>
      </div>
      <div class="settings-actions">
        <button id="btn-settings-close" class="settings-close">Èñâ„Åò„Çã</button>
      </div>
    </div>
  </div>
  <div id="hud">
    <div></div>
    <div id="call">Enter</div>
    <div style="display: grid; gap: 6px; justify-items: center;">
      <div id="status"></div>
      <div id="bar"><span id="score-left">Â∑¶ 0</span><span>ÔΩú</span><span id="score-right">Âè≥ 0</span></div>
      <div id="keys" style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;justify-content:center;">
        <span id="keys-text">A/S/D ÔΩú ;/:/]</span>
        <button id="hud-input" style="padding:4px 10px;font-weight:800;border:none;border-radius:8px;background:#0b1720;color:#fff;cursor:pointer;">ÂÖ•Âäõ:„Ç≠„Éº</button>
        <span style="font-size:0.8rem;opacity:0.8;">R„Åß„É™„Çª„ÉÉ„Éà</span>
        <button id="btn-report" style="padding:4px 10px;font-weight:800;border:none;border-radius:8px;background:#ffdf4c;color:#0b1720;cursor:pointer;display:none;">„É¨„Éù„Éº„ÉàDL</button>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script>
    // Perf/visual switches
    const PERF = { fx: "minimal" }; // "minimal" | "high"
    // Outline scales (global + per-type)
    const OUTLINE_SCALE_GLOBAL = 1.0;
    const OUTLINE_SCALE_PLAYER = 1.0;
    const OUTLINE_SCALE_HEAD = 1.05;
    // Tuning: how fast headgear flies when knocked off
    const HEADGEAR_KNOCK_SPEED = 1.2;
    // --- Simple sound kit (inline data URIs to avoid asset hosting) ---
    const sounds = {
      count: new Audio("data:audio/wav;base64,UklGRgYAAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YQAAAACAgICAgICAgICAgICAgICA"),
      charge: new Audio("data:audio/wav;base64,UklGRmQAAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YQAAAP/f3+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+fn5+f"),
      shot: new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YQAAAAAA//+AgID///8AAP//gICA//8AAP//gICA//8AAP//gICA"),
      hit: new Audio("data:audio/wav;base64,UklGRhQAAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YQAAAP//AACAgP//AACAgP//AACAgP//AACAgP//AACAgP//AACAgP//AACAgA=="),
      guard: new Audio("data:audio/wav;base64,UklGRhQAAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YQAAAP//gICA//+AgID///8AAP//gICA//+AgID///8AAP//gICA"),
      win: new Audio("data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAIA+AAACABAAZGF0YQAAAP//AACAgP//AACAgP//AACAgP//AACAgP//AACAgP//AACAgP//AACAgA=="),
    };
    Object.values(sounds).forEach((s) => { s.volume = 0.7; });

    // Basic THREE setup
    const canvas = document.getElementById("scene");
    const fxLayer = document.getElementById("fx-layer");
    const isMobile = /iPhone|iPad|Android/i.test(navigator.userAgent);
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: false }); // disable MSAA for higher FPS
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 0.85)); // drop resolution a bit more for speed

    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#f5c000");
    const camera = new THREE.PerspectiveCamera(48, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 2.5, 10);

    const light = new THREE.DirectionalLight(0xffffff, 1.2);
    light.position.set(4, 8, 6);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0xffffff, 0.01));
    // Add stronger back/rim and sky/ground fill for contrasty shading
    const rimLight = new THREE.DirectionalLight(0xfff6d2, 1.2);
    rimLight.position.set(-6, 6, -8);
    scene.add(rimLight);
    const hemi = new THREE.HemisphereLight(0xe8f4ff, 0xf5c000, 0.4);
    scene.add(hemi);

    // Ground plane for reference
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(30, 12),
      new THREE.MeshPhongMaterial({ color: 0xf5c000, side: THREE.DoubleSide, depthWrite: false })
    );
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = -2;
    ground.renderOrder = -10; // always draw behind players/outline
    scene.add(ground);

    // Helpers to create players and props
    function makePlayer(color, x) {
      const group = new THREE.Group();
      group.position.set(x, -1.2, 0);
      group.userData = { baseX: x, targetX: x };
      group.rotation.y = Math.sign(x) * 1;

    const toonMaterial = (color) => new THREE.MeshToonMaterial({ color, gradientMap: null });
      const bottleMat = toonMaterial(color);

      const body = new THREE.Mesh(
        new THREE.CapsuleGeometry(0.8, 1.6, 24, 32),
        bottleMat
      );
      body.position.y = 1.0;
      group.add(body);
      group.add(makeOutline(body, 1.06, "player"));

      const shoulder = new THREE.Mesh(
        new THREE.SphereGeometry(0.8, 32, 32),
        bottleMat
      );
      shoulder.position.set(0, 2.0, 0);
      group.add(shoulder);
      group.add(makeOutline(shoulder, 1.06, "player"));

      const capMat = toonMaterial(color);
      const cap = new THREE.Mesh(
        new THREE.CylinderGeometry(0.45, 0.45, 0.28, 36, 1, true),
        capMat
      );
      cap.position.set(0, 2.55, 0);
      group.add(cap);
      group.add(makeOutline(cap, 1.06, "player"));
      // (grooves removed for cleaner head silhouette)

      const label = new THREE.Mesh(
        new THREE.CylinderGeometry(0.86, 0.86, 0.8, 40, 1, true),
        new THREE.MeshToonMaterial({
          color: 0xfff6b0,
          transparent: true,
          opacity: 0.92,
          side: THREE.DoubleSide,
        })
      );
      label.position.y = 0.95;
      group.add(label);
      group.add(makeOutline(label, 1.05, "player"));

      const belt = new THREE.Mesh(
        new THREE.BoxGeometry(1.2, 0.26, 0.06),
        toonMaterial(x > 0 ? 0x111111 : 0xffffff)
      );
      belt.position.set(0, 1.1, 0.9);
      group.add(belt);
      group.add(makeOutline(belt, 1.05, "player"));

      const gun = new THREE.Mesh(
        new THREE.BoxGeometry(0.28, 0.3, 1.6),
        toonMaterial(0x111111)
      );
      gun.position.set(x > 0 ? -0.65 : 0.65, 1.3, 0.9);
      gun.rotation.y = x > 0 ? Math.PI / 7 : -Math.PI / 7;
      gun.name = "gun";
      group.add(gun);
      group.add(makeOutline(gun, 1.05, "player"));

      const shield = new THREE.Mesh(
        new THREE.BoxGeometry(1.2, 1.5, 0.18),
        new THREE.MeshToonMaterial({
          color: 0x0ae2ff,
          transparent: true,
          opacity: 0.75,
          side: THREE.DoubleSide,
        })
      );
      shield.position.set(x > 0 ? -0.7 : 0.7, 1.3, 1.05);
      shield.rotation.y = x > 0 ? Math.PI / 7 : -Math.PI / 7;
      shield.visible = false;
      shield.name = "shield";
      group.add(shield);
      group.add(makeOutline(shield, 1.04, "player"));

      const chargeGroup = new THREE.Group();
      chargeGroup.name = "chargeGroup";
      chargeGroup.position.set(0, 3.3, 0);
      group.add(chargeGroup);

      const labelSprite = makeLabelSprite("1P");
      labelSprite.position.set(0, 3.9, 0);
      labelSprite.name = "label";
      group.add(labelSprite);

      const headAnchor = new THREE.Group();
      headAnchor.name = "headAnchor";
      headAnchor.position.set(0, 2.6, 0);
      group.add(headAnchor);
      group.userData.color = color;

      scene.add(group);
      return group;
    }

    const leftPlayer = makePlayer(0x1f7be0, -3.4);
    const rightPlayer = makePlayer(0xe23b2c, 3.4);
    // Flip face to the opposite side for right player
    if (rightPlayer.userData.face) {
      rightPlayer.userData.face.position.x *= -1;
      rightPlayer.userData.face.rotation.y = Math.PI; // turn to face outward
    }

    // Bullets and particles pool
    const bullets = [];
    const splashes = [];
    const rains = [];
    const guards = [];
    const knockedHats = [];
    const stars = [];
    const chargeGlows = [];
    const damageTrails = [];
    const barriers = [];
    const confettis = [];
    const honeycombs = [];
    const streaks = [];
    let cpuTimeout = null;
    let nextRoundTimeout = null;
    let celebrateTimer = 0;
    let followTarget = null;
    let cameraReady = false;
    let hitFreezeTimer = 0;
    const gestures = { left: null, right: null };
    const gestureCache = { left: null, right: null }; // keep recent gestures to avoid frame drops
    const debugState = { left: null, right: null };

    function trimPool(arr, max) {
      while (arr.length > max) {
        const item = arr.shift();
        if (item && item.parent) item.parent.remove(item);
      }
    }

    function spawnBullet(fromLeft, willHit, unstoppable = false) {
      const geom = new THREE.SphereGeometry(0.2, 28, 28);
      const bullet = new THREE.Mesh(
        geom,
        new THREE.MeshToonMaterial({ color: 0xf9e463, emissive: 0xc8a400, gradientMap: null })
      );
      bullet.scale.set(1, 1, 1.8); // „É¨„É¢„É≥Âûã
      bullet.position.copy(fromLeft ? leftPlayer.position : rightPlayer.position);
      bullet.position.y = 1.2;
      bullet.position.z = 0.2;
      bullet.userData = {
        dir: fromLeft ? 1 : -1,
        life: 2.5,
        willHit,
        target: fromLeft ? rightPlayer : leftPlayer,
        fromLeft,
        unstoppable,
      };
      // Outline for visibility
      const outline = makeOutline(bullet, 1.08, "head");
      scene.add(bullet);
      scene.add(outline);
      bullets.push(bullet);
      trimPool(bullets, 24);
      // Keep outline paired with bullet
      bullet.userData.outline = outline;
      outline.userData = { bullet };
      spawnSpeedLine(fromLeft);
    }

    function spawnSplash(targetPlayer) {
      const lite = PERF.fx === "low";
      const base = targetPlayer.position.clone();
      base.y = 1.1;
      const count = PERF.fx === "minimal" ? 4 : lite ? 8 : 16;
      for (let i = 0; i < count; i++) {
        const drop = new THREE.Mesh(
          new THREE.SphereGeometry(0.08 + Math.random() * 0.06, 14, 14),
          new THREE.MeshStandardMaterial({ color: 0xf9e463, emissive: 0xc8a400, roughness: 0.4, metalness: 0.05 })
        );
        drop.position.copy(base);
        drop.userData = {
          vel: new THREE.Vector3(
            (Math.random() - 0.5) * 2.2,
            Math.random() * 2.4,
            (Math.random() - 0.5) * 1.8
          ),
          life: 1.2,
        };
        scene.add(drop);
        splashes.push(drop);
        trimPool(splashes, 50);
      }
    }

    function spawnChargeRain(player) {
      const base = player.position.clone();
      if (PERF.fx === "minimal") return;
      const count = PERF.fx === "low" ? 6 : 12;
      for (let i = 0; i < count; i++) {
        const orb = new THREE.Mesh(
          new THREE.SphereGeometry(0.12, 20, 20),
          new THREE.MeshPhongMaterial({ color: 0xf9e463, emissive: 0xc8a400, transparent: true, opacity: 0.9 })
        );
        orb.position.set(
          base.x + (Math.random() - 0.5) * 1.4,
          3 + Math.random() * 2,
          (Math.random() - 0.5) * 1.4
        );
        orb.userData = {
          velY: - (0.8 + Math.random() * 0.8),
          life: 1.6,
          pull: new THREE.Vector3(
            (base.x - orb.position.x) * 0.6,
            (2.4 - orb.position.y) * 0.5,
            (0 - orb.position.z) * 0.6
          ),
        };
        scene.add(orb);
        rains.push(orb);
        trimPool(rains, 40);
      }
    }

    function addStain(player) {
      const count = 4 + Math.floor(Math.random() * 4);
      if (!player.userData.stains) player.userData.stains = [];
      for (let i = 0; i < count; i++) {
        const stain = new THREE.Mesh(
          new THREE.SphereGeometry(0.14 + Math.random() * 0.18, 22, 22),
          new THREE.MeshStandardMaterial({ color: 0xf9e463, emissive: 0xc8a400, roughness: 0.5, metalness: 0.05 })
        );
        stain.position.set(
          (Math.random() - 0.5) * 0.9,
          0.5 + Math.random() * 1.6,
          0.35 + Math.random() * 0.5
        );
        stain.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        player.add(stain);
        player.userData.stains.push(stain);
        if (player.userData.stains.length > 18) {
          const old = player.userData.stains.shift();
          player.remove(old);
        }
      }
      cameraKick(0.9);
    }

    function knockBack(player, dir) {
      player.userData.knock = {
        hold: 0.3,
        launchX: dir * 100,
        launchY: 0,
      };
      camDistTarget = 18;
      camFocusTargetX = player.position.x;
      followTarget = player;
      player.userData.flightLife = 2.8;
      cameraKick(1.0);
      state.waitingReturn = true;
    }

    function spawnWinBurst(player) {
      const base = player.position.clone();
      base.y = 1.4;
      const count = PERF.fx === "minimal" ? 12 : PERF.fx === "low" ? 18 : 50;
      for (let i = 0; i < count; i++) {
        const drop = new THREE.Mesh(
          new THREE.SphereGeometry(0.12 + Math.random() * 0.08, 12, 12),
          new THREE.MeshStandardMaterial({ color: 0xfff2a8, emissive: 0xe1c453, transparent: true, opacity: 0.95, roughness: 0.4, metalness: 0.05 })
        );
        drop.position.copy(base);
        drop.userData = {
          vel: new THREE.Vector3(
            (Math.random() - 0.5) * 6,
            Math.random() * 6.5,
            (Math.random() - 0.5) * 6
          ),
          life: 1.6,
        };
        scene.add(drop);
        splashes.push(drop);
      }
    }

    function triggerCelebrate() {
      const champ = state.pendingCelebrate;
      if (!champ) return;
      champ.visible = true;
      champ.userData.celebrate = 2.0;
      spawnWinBurst(champ);
      spawnWinConfetti(champ);
      focusOn(champ.position.x, 1.2, 7.0);
      cameraKick(0.9);
      state.pendingCelebrate = null;
    }

    function resetPlayersPose() {
      const baseY = -1.2;
      [leftPlayer, rightPlayer].forEach((p) => {
        p.position.x = p.userData.baseX;
        p.position.y = baseY;
        p.userData.targetX = p.userData.baseX;
        delete p.userData.kb;
        delete p.userData.knock;
        delete p.userData.celebrate;
        delete p.userData.flightLife;
        p.rotation.set(0, 0, 0);
        p.visible = true;
      });
      followTarget = null;
      state.waitingReturn = false;
      // Ensure visuals are present after knockback/round transitions
      attachHeadgear(leftPlayer, state.headgear?.left || config.headgear.left || 0, -1);
      attachHeadgear(rightPlayer, state.headgear?.right || config.headgear.right || 0, 1);
      updateChargeOrbs(leftPlayer, state.charges.left);
      updateChargeOrbs(rightPlayer, state.charges.right);
    }

    function updateChargeOrbs(player, count) {
      const group = player.getObjectByName("chargeGroup");
      if (!group) return;
      const pairCount = () => Math.floor(group.children.length / 2);
      while (pairCount() > count) {
        const outline = group.children.pop();
        const orb = group.children.pop();
        if (outline) group.remove(outline);
        if (orb) group.remove(orb);
      }
      while (pairCount() < count) {
        const orb = new THREE.Mesh(
          new THREE.SphereGeometry(0.2, 24, 24),
          new THREE.MeshToonMaterial({ color: 0x78ff78, emissive: 0x2fbf2f, gradientMap: null })
        );
        const idx = pairCount();
        orb.position.set((idx - (count - 1) / 2) * 0.5, 0.6 + Math.sin(idx) * 0.05, 0);
        const outline = makeOutline(orb, 1.08, "head"); // use headgear outline style for visibility
        group.add(orb);
        group.add(outline);
      }
      // Sync positions for orbs and outlines (orbs first, outlines follow)
      for (let i = 0; i < pairCount(); i++) {
        const orb = group.children[i * 2];
        const outline = group.children[i * 2 + 1];
        if (orb && orb.isMesh) {
          orb.position.x = (i - (count - 1) / 2) * 0.5;
          orb.position.y = 1.5 + Math.sin(performance.now() * 0.002 + i) * 0.1;
        }
        if (outline && outline.isMesh && orb) {
          outline.position.copy(orb.position);
        }
      }
    }

    function makeLabelTexture(text) {
      const size = 128;
      const fontSize = text.length > 2 ? 50 : 64;
      const canvasTag = document.createElement("canvas");
      canvasTag.width = canvasTag.height = size;
      const ctx = canvasTag.getContext("2d");
      ctx.clearRect(0, 0, size, size);
      ctx.fillStyle = "rgba(0,0,0,0.78)";
      ctx.font = `bold ${fontSize}px 'Noto Sans JP', sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, size / 2, size / 2);
      const texture = new THREE.CanvasTexture(canvasTag);
      texture.needsUpdate = true;
      return texture;
    }

    function makeLabelSprite(text) {
      const texture = makeLabelTexture(text);
      const material = new THREE.SpriteMaterial({ map: texture, transparent: true, depthTest: false });
      const sprite = new THREE.Sprite(material);
      const scale = text.length > 2 ? 1.2 : 1.5;
      sprite.scale.set(scale, scale, 1);
      return sprite;
    }

    // State
    const mapping = {
      left: { a: "charge", s: "gun", d: "guard", ArrowLeft: "charge", ArrowDown: "gun", ArrowRight: "guard" },
      right: {
        ";": "charge", ":": "gun", "]": "guard",
        Semicolon: "charge", Quote: "gun", BracketRight: "guard",
      },
    };
    const SHIELD_MAX_WHIFTS = 3;
    const HEALTH_HIT = 0.35;
    const HEALTH_GUARD_HEAL = 0.12;
    const BOOST_MAX = 3;
    const state = {
      scores: { left: 0, right: 0 },
      charges: { left: 0, right: 0 },
      choices: { left: null, right: null },
      roundOpen: false,
      sequenceRunning: false,
      timerId: null,
      winner: null,
      mode: null, // "pvp" or "cpu"
      pendingCelebrate: null,
      shieldWhiffs: { left: 0, right: 0 },
      shieldLocked: { left: false, right: false },
      health: { left: 1, right: 1 },
      boost: {
        left: { gauge: 0, ready: false },
        right: { gauge: 0, ready: false },
      },
      cpuMode: "normal",
      waitingReturn: false,
      history: [],
    };

    const callEl = document.getElementById("call");
    const statusEl = document.getElementById("status");
    const scoreLeft = document.getElementById("score-left");
    const scoreRight = document.getElementById("score-right");
    const controlModeLabel = document.getElementById("control-mode-label");
    const startScreen = document.getElementById("start-screen");
    const btn1p = document.getElementById("btn-1p");
    const btn2p = document.getElementById("btn-2p");
    const btnSettingsStart = document.getElementById("btn-settings");
    const settingsOverlay = document.getElementById("settings-overlay");
    const btnSettingsClose = document.getElementById("btn-settings-close");
    const settingsButtons = document.querySelectorAll("[data-input-mode]");
    const chkHandLines = document.getElementById("chk-hand-lines");
    const chkDebug = document.getElementById("chk-debug");
    const floatingSettingsButton = document.getElementById("settings-button");
    const inputBadge = document.getElementById("btn-input");
    const btnReport = document.getElementById("btn-report");
    const btnImportWeights = document.createElement("button");
    btnImportWeights.textContent = "„Ç¶„Çß„Ç§„ÉàË™≠Ëæº";
    btnImportWeights.id = "btn-import-weights";
    btnImportWeights.style.cssText = "padding:4px 10px;font-weight:800;border:none;border-radius:8px;background:#ffe2ff;color:#0b1720;cursor:pointer;display:none;";
    const hudInputBadge = document.getElementById("hud-input");
    const camEl = document.getElementById("cam");
    const lineLeft = document.getElementById("line-left");
    const lineRight = document.getElementById("line-right");
    const shieldMeterLeft = document.getElementById("shield-meter-left");
    const shieldMeterRight = document.getElementById("shield-meter-right");
    // Hide legacy 2D shield meters (now replaced by 3D rings)
    if (shieldMeterLeft) shieldMeterLeft.style.display = "none";
    if (shieldMeterRight) shieldMeterRight.style.display = "none";
    const juiceLeft = document.getElementById("juice-left");
    const juiceRight = document.getElementById("juice-right");
    const boostPillLeft = document.getElementById("boost-pill-left");
    const boostPillRight = document.getElementById("boost-pill-right");
    const boostFillLeft = document.getElementById("boost-fill-left");
    const boostFillRight = document.getElementById("boost-fill-right");
    const cpuButtons = document.querySelectorAll("[data-cpu]");
    const headButtons = document.querySelectorAll(".pill-head");
    const headLeftLabel = document.getElementById("head-left-label");
    const headRightLabel = document.getElementById("head-right-label");
    const debugEl = document.getElementById("debug");
    const debugCanvas = document.getElementById("debug-canvas");
    const debugCtx = debugCanvas.getContext("2d");
    const configKey = "cc-lemon-settings";
    const config = {
      inputMode: "keyboard", // keyboard | hand
      showHandLines: true,
      showDebug: false,
      headgear: { left: 0, right: 0 },
      cpuWeights: { charge: 0.33, gun: 0.33, guard: 0.34 }, // used in ultra mode
    };
    const headgearNames = [
      "„Å™„Åó",
      "„É¨„É¢„É≥„Ç≠„É£„ÉÉ„Éó",
      "ÁéãÂÜ†",
      "„Éò„ÉÉ„Éâ„Éõ„É≥",
      "„Ç∑„Çß„ÉïÂ∏Ω",
      "„Ç∑„É´„ÇØ„Éè„ÉÉ„Éà",
      "„Éò„É´„É°„ÉÉ„Éà",
      "„Ç¢„Éã„Éû„É´ËÄ≥",
      "„Åü„Åæ„ÅîÂØøÂè∏",
      "„Å≠„Åò„Çä„Éè„ÉÅ„Éû„Ç≠",
      "„Ç´„Ç¶„Éú„Éº„Ç§",
    ];
    let debugEnabled = false;

    function refreshUI(hidden = true) {
      if (!state.headgear) state.headgear = { left: config.headgear.left || 0, right: config.headgear.right || 0 };
      scoreLeft.textContent = `Â∑¶ ${state.scores.left}`;
      scoreRight.textContent = `Âè≥ ${state.scores.right}`;
      updateChargeOrbs(leftPlayer, state.charges.left);
      updateChargeOrbs(rightPlayer, state.charges.right);
      updateHealthUI();
      updateBoostUI();
      updateShieldMeters();
      attachHeadgear(leftPlayer, state.headgear.left, -1);
      attachHeadgear(rightPlayer, state.headgear.right, 1);
      updateLabels();
      if (hidden) return;
    }

    function updateLabels() {
      const leftLabel = leftPlayer.getObjectByName("label");
      const rightLabel = rightPlayer.getObjectByName("label");
      if (leftLabel) {
        leftLabel.material.map = makeLabelTexture("1P");
        leftLabel.material.needsUpdate = true;
      }
      const rightText = state.mode === "cpu" ? "CPU" : "2P";
      if (rightLabel) {
        rightLabel.material.map = makeLabelTexture(rightText);
        rightLabel.material.needsUpdate = true;
      }
    }

    function loadConfig() {
      try {
        const raw = localStorage.getItem(configKey);
        if (!raw) return;
        const stored = JSON.parse(raw);
        if (stored.inputMode) config.inputMode = stored.inputMode;
        if (typeof stored.showHandLines === "boolean") config.showHandLines = stored.showHandLines;
        if (typeof stored.showDebug === "boolean") config.showDebug = stored.showDebug;
        if (stored.headgear) {
          if (typeof stored.headgear.left === "number") config.headgear.left = stored.headgear.left;
          if (typeof stored.headgear.right === "number") config.headgear.right = stored.headgear.right;
        }
      } catch (e) {
        console.warn("Ë®≠ÂÆö„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü", e);
      }
    }

    function saveConfig() {
      localStorage.setItem(configKey, JSON.stringify(config));
    }

    function downloadReport() {
      const report = {
        time: new Date().toISOString(),
        mode: state.mode,
        cpuMode: state.cpuMode,
        scores: state.scores,
        winner: state.winner,
        headgear: { ...state.headgear },
        history: state.history,
      };
      const blob = new Blob([JSON.stringify(report, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "cc-lemon-report.json";
      a.click();
      URL.revokeObjectURL(url);
    }

    function updateControlBadges() {
      const label = config.inputMode === "hand" ? "„Éè„É≥„Éâ" : "„Ç≠„Éº";
      controlModeLabel.textContent = label;
      if (inputBadge) inputBadge.textContent = label;
      if (hudInputBadge) hudInputBadge.textContent = `ÂÖ•Âäõ:${label}`;
      if (btnReport) btnReport.style.display = "none";
      if (btnImportWeights) btnImportWeights.style.display = "none";
      settingsButtons.forEach((btn) => {
        btn.classList.toggle("active", btn.dataset.inputMode === config.inputMode);
      });
      chkHandLines.checked = config.showHandLines;
      chkDebug.checked = config.showDebug;
      headLeftLabel.textContent = headgearNames[config.headgear.left] || "„Å™„Åó";
      headRightLabel.textContent = headgearNames[config.headgear.right] || "„Å™„Åó";
    }

    function openSettings() {
      settingsOverlay.style.display = "grid";
      settingsOverlay.setAttribute("aria-hidden", "false");
    }

    function closeSettings() {
      settingsOverlay.style.display = "none";
      settingsOverlay.setAttribute("aria-hidden", "true");
    }

    function toggleHandLines(show) {
      config.showHandLines = show;
      saveConfig();
      updateHandLines();
    }

    function ensureDebug(target) {
      if (typeof target === "boolean") {
        toggleDebug(target);
      }
      config.showDebug = debugEnabled;
      saveConfig();
    }

    function setInputMode(mode) {
      if (!mode) return;
      config.inputMode = mode;
      saveConfig();
      updateControlBadges();
      if (config.inputMode === "hand") {
        initCamera();
      }
    }

    function setHeadgear(side, dir) {
      const listLen = headgearNames.length;
      const current = config.headgear[side] || 0;
      const next = (current + dir + listLen) % listLen;
      config.headgear[side] = next;
      saveConfig();
      updateControlBadges();
      attachHeadgear(side === "left" ? leftPlayer : rightPlayer, next, side === "left" ? -1 : 1);
    }

    function registerChoice(side, action) {
      if (!state.roundOpen || state.winner || state.choices[side]) return false;
      if (action === "guard" && state.shieldLocked[side]) {
        statusEl.textContent = `${side === "left" ? "Â∑¶" : "Âè≥"} „Ç∑„Éº„É´„ÉâÂ∞ÅÂç∞‰∏≠`;
        // „Åù„ÅÆÂ†¥„ÅßÂ§±ÊïóÊºîÂá∫„Å†„ÅëÂá∫„Åó„Å¶ÂÖ•Âäõ„ÇíÊ∂àË≤ª„Åó„ÄÅÂæÖ„Å°ÊôÇÈñì„ÇíÊ∏õ„Çâ„Åô
        flashLockedTint(side === "left" ? leftPlayer : rightPlayer);
        state.choices[side] = "none";
        state.history.push({
          round: state.history.length + 1,
          leftChoice: side === "left" ? "guard-locked" : null,
          rightChoice: side === "right" ? "guard-locked" : null,
          scores: { ...state.scores },
          call: "Â∞ÅÂç∞„Ç¨„Éº„Éâ",
          detail: "",
          time: Date.now(),
          
        });
        return true;
      }
      state.choices[side] = action;
      if (side === "left" && state.mode === "cpu" && !state.choices.right) {
        scheduleCpuChoice(true);
      }
      return true;
    }

    loadConfig();
    updateControlBadges();
    toggleHandLines(config.showHandLines);
    ensureDebug(config.showDebug);

    function startSequence() {
      if (state.sequenceRunning || state.winner || state.waitingReturn) return;
      if (!state.mode) return;
      // Re-attach visuals in case they were hidden/removed in the previous exchange
      attachHeadgear(leftPlayer, state.headgear?.left || config.headgear.left || 0, -1);
      attachHeadgear(rightPlayer, state.headgear?.right || config.headgear.right || 0, 1);
      updateChargeOrbs(leftPlayer, state.charges.left);
      updateChargeOrbs(rightPlayer, state.charges.right);
      state.sequenceRunning = true;
      state.choices = { left: null, right: null };
      state.roundOpen = false;
      refreshUI(true);
      camFocusTargetX = 0;
      camDistTarget = 9.6;
      statusEl.textContent = "";
      const calls = ["üçã", "üçãüçã", "üçãüçãüçã"];
      callEl.classList.add("flash");
      callEl.classList.add("call-pop");
      const bgSteps = [0xf5c000, 0xf5d94c, 0xffe678];
      const step = (idx) => {
        if (idx >= calls.length) {
          callEl.classList.remove("flash");
          callEl.classList.remove("call-pop");
          state.sequenceRunning = false;
          startRound();
          return;
        }
        callEl.textContent = calls[idx];
        statusEl.textContent = "";
        scene.background = new THREE.Color(bgSteps[idx] || 0xf5c000);
        if (sounds.count) { sounds.count.currentTime = 0; sounds.count.play(); }
        if (idx === calls.length - 1 && PERF.fx === "high") spawnScreenFlash();
        cameraKick(0.35, false); // keep UI steady during count
        setTimeout(() => step(idx + 1), 500);
      };
      step(0);
    }

    function startRound() {
      state.roundOpen = true;
      statusEl.textContent = "";
      callEl.textContent = "ÂÖ•Âäõ";
      callEl.classList.remove("call-pop");
      void callEl.offsetWidth;
      callEl.classList.add("call-pop");
      clearTimeout(state.timerId);
      state.timerId = setTimeout(resolveRound, 1800);
      hideShields();
    }

    function resolveRound() {
      if (!state.roundOpen) return;
      state.roundOpen = false;
      clearTimeout(state.timerId);
      clearTimeout(cpuTimeout);
      clearTimeout(nextRoundTimeout);
      if (!state.choices.left) state.choices.left = "none";
      if (!state.choices.right) state.choices.right = "none";
      const prevScores = { ...state.scores };
      const outcome = judge(state.choices.left, state.choices.right);
      state.history.push({
        round: state.history.length + 1,
        leftChoice: state.choices.left,
        rightChoice: state.choices.right,
        scores: { ...state.scores },
        call: outcome.call,
        detail: outcome.detail,
        time: Date.now(),
      });
      applyHealthChanges(outcome);
      refreshUI(false);
      handleVisuals(outcome.visuals);
      callEl.textContent = outcome.call;
      statusEl.textContent = outcome.detail;
      applyShieldLimits(prevScores, outcome);
      checkWinner();
      if (!state.winner) {
        const hit = outcome.visuals.hitLeft || outcome.visuals.hitRight;
        if (hit) {
          scheduleResetAfterHit();
        } else {
          nextRoundTimeout = setTimeout(() => startSequence(), 900);
        }
      }
    }

    function judge(left, right) {
      const leftGunAttempt = left === "gun";
      const rightGunAttempt = right === "gun";
      const leftGunReady = leftGunAttempt && state.charges.left > 0;
      const rightGunReady = rightGunAttempt && state.charges.right > 0;

      if (left === "charge") {
        state.charges.left += 1;
        addBoostCharge("left");
        if (sounds.charge) { sounds.charge.currentTime = 0; sounds.charge.play(); }
      }
      if (right === "charge") {
        state.charges.right += 1;
        addBoostCharge("right");
        if (sounds.charge) { sounds.charge.currentTime = 0; sounds.charge.play(); }
      }
      if (left === "gun" && state.charges.left > 0) state.charges.left -= 1;
      if (right === "gun" && state.charges.right > 0) state.charges.right -= 1;

      let burstLeft = false;
      let burstRight = false;
      let perfectShieldLeft = false;
      let perfectShieldRight = false;
      if (state.boost.left.ready) {
        if (left === "gun" && leftGunReady) { burstLeft = true; consumeBoost("left"); }
        else if (left === "guard") { perfectShieldLeft = true; consumeBoost("left"); }
      }
      if (state.boost.right.ready) {
        if (right === "gun" && rightGunReady) { burstRight = true; consumeBoost("right"); }
        else if (right === "guard") { perfectShieldRight = true; consumeBoost("right"); }
      }

      const visuals = {
        left: leftGunReady ? "gun" : left === "guard" ? "shield" : null,
        right: rightGunReady ? "gun" : right === "guard" ? "shield" : null,
        chargeLeft: left === "charge",
        chargeRight: right === "charge",
        hitLeft: false,
        hitRight: false,
        burstLeft,
        burstRight,
        perfectShieldLeft,
        perfectShieldRight,
      };

      const guardSuccessLeft = (left === "guard" && rightGunReady) || perfectShieldLeft;
      const guardSuccessRight = (right === "guard" && leftGunReady) || perfectShieldRight;
      const whiffLeft = left === "guard" && !guardSuccessLeft;
      const whiffRight = right === "guard" && !guardSuccessRight;
      const extra = [];
      if (burstLeft) extra.push("Â∑¶ „É¨„É¢„É≥„Çπ„Ç≥„Éº„É´");
      if (burstRight) extra.push("Âè≥ „É¨„É¢„É≥„Çπ„Ç≥„Éº„É´");
      if (perfectShieldLeft) extra.push("Â∑¶ „Éì„Çø„Éü„É≥„Ç∑„Éº„É´„Éâ");
      if (perfectShieldRight) extra.push("Âè≥ „Éì„Çø„Éü„É≥„Ç∑„Éº„É´„Éâ");

      if (leftGunReady && rightGunReady) {
        return { call: "Áõ∏ÊÆ∫ÔºÅ", detail: extra.join(" "), visuals, whiffLeft, whiffRight, guardSuccessLeft, guardSuccessRight, perfectShieldLeft, perfectShieldRight };
      }
      if (leftGunReady && !rightGunReady) {
        if (right === "guard") return { call: "Èò≤„Åå„Çå„Åü", detail: extra.join(" "), visuals, whiffLeft, whiffRight, guardSuccessLeft, guardSuccessRight, perfectShieldLeft, perfectShieldRight };
        state.scores.left += 1;
        visuals.hitRight = true;
        return { call: "Â∑¶„Éí„ÉÉ„Éà", detail: extra.join(" "), visuals, whiffLeft, whiffRight, guardSuccessLeft, guardSuccessRight, perfectShieldLeft, perfectShieldRight };
      }
      if (rightGunReady && !leftGunReady) {
        if (left === "guard") return { call: "Èò≤„ÅÑ„Å†", detail: extra.join(" "), visuals, whiffLeft, whiffRight, guardSuccessLeft, guardSuccessRight, perfectShieldLeft, perfectShieldRight };
        state.scores.right += 1;
        visuals.hitLeft = true;
        return { call: "Âè≥„Éí„ÉÉ„Éà", detail: extra.join(" "), visuals, whiffLeft, whiffRight, guardSuccessLeft, guardSuccessRight, perfectShieldLeft, perfectShieldRight };
      }
      if (leftGunAttempt && !leftGunReady) {
        return { call: "Â∑¶ Âºæ„Å™„Åó", detail: "„ÉÅ„É£„Éº„Ç∏‰∏çË∂≥", visuals, whiffLeft, whiffRight, guardSuccessLeft, guardSuccessRight, perfectShieldLeft, perfectShieldRight };
      }
      if (rightGunAttempt && !rightGunReady) {
        return { call: "Âè≥ Âºæ„Å™„Åó", detail: "„ÉÅ„É£„Éº„Ç∏‰∏çË∂≥", visuals, whiffLeft, whiffRight, guardSuccessLeft, guardSuccessRight, perfectShieldLeft, perfectShieldRight };
      }
      if (left === "none" && right === "none") {
        return { call: "ÈùôÂØÇ", detail: extra.join(" "), visuals, whiffLeft, whiffRight, guardSuccessLeft, guardSuccessRight, perfectShieldLeft, perfectShieldRight };
      }
      return {
        call: "Á∂öË°å",
        detail: extra.join(" "),
        visuals,
        whiffLeft,
        whiffRight,
        guardSuccessLeft,
        guardSuccessRight,
        perfectShieldLeft,
        perfectShieldRight,
      };
    }

    function applyShieldLimits(prevScores, outcome) {
      if (!outcome) return;
      const messages = [];
      const bump = (side, whiffed) => {
        if (state.scores[side] > prevScores[side]) {
          state.shieldWhiffs[side] = 0;
          state.shieldLocked[side] = false;
        }
        if (whiffed) {
          state.shieldWhiffs[side] = (state.shieldWhiffs[side] || 0) + 1;
          if (state.shieldWhiffs[side] >= SHIELD_MAX_WHIFTS && !state.shieldLocked[side]) {
            state.shieldLocked[side] = true;
            messages.push(`${side === "left" ? "Â∑¶" : "Âè≥"} „Ç∑„Éº„É´„ÉâÂ∞ÅÂç∞`);
          }
        }
      };
      bump("left", !!outcome.whiffLeft);
      bump("right", !!outcome.whiffRight);
      if (messages.length) {
        const tail = messages.join(" / ");
        statusEl.textContent = statusEl.textContent ? `${statusEl.textContent} | ${tail}` : tail;
      }
      updateShieldMeters();
      if (state.scores.left > prevScores.left) flashScore("left");
      if (state.scores.right > prevScores.right) flashScore("right");
    }

    function applyHealthChanges(outcome) {
      if (!outcome) return;
      if (outcome.visuals.hitLeft) adjustHealth("left", -HEALTH_HIT);
      if (outcome.visuals.hitRight) adjustHealth("right", -HEALTH_HIT);
      if (outcome.guardSuccessLeft) {
        adjustHealth("left", HEALTH_GUARD_HEAL + (outcome.perfectShieldLeft ? 0.05 : 0));
      }
      if (outcome.guardSuccessRight) {
        adjustHealth("right", HEALTH_GUARD_HEAL + (outcome.perfectShieldRight ? 0.05 : 0));
      }
    }

    function checkWinner() {
      const leftDead = state.health.left <= 0;
      const rightDead = state.health.right <= 0;
      if (leftDead || rightDead || state.scores.left >= 3 || state.scores.right >= 3) {
        if (leftDead && !rightDead) state.winner = "Âè≥";
        else if (rightDead && !leftDead) state.winner = "Â∑¶";
        else state.winner = state.scores.left > state.scores.right ? "Â∑¶" : "Âè≥";
        callEl.textContent = `${state.winner} ÂãùÂà©`;
        statusEl.textContent = "R";
        state.pendingCelebrate = state.winner === "Â∑¶" ? leftPlayer : rightPlayer;
        if (sounds.win) { sounds.win.currentTime = 0; sounds.win.play(); }
      if (btnReport) btnReport.style.display = "inline-block";
        if (btnImportWeights) btnImportWeights.style.display = "inline-block";
      }
    }

    function handleKey(e) {
      const key = e.key;
      const code = e.code;
      if (key === "F3") {
        toggleDebug();
        return;
      }
      if (key.toLowerCase() === "r") {
        resetGame(true);
        return;
      }
      const leftKeyboardAllowed = config.inputMode === "keyboard";
      if (!state.roundOpen || state.winner) return;
      if (leftKeyboardAllowed) {
        const action = mapping.left[key] || mapping.left[key.toLowerCase()] || mapping.left[code];
        if (action && registerChoice("left", action) && state.mode === "cpu" && !state.choices.right) {
          scheduleCpuChoice(true);
        }
      }
      if (state.mode !== "cpu") {
        const actionR = mapping.right[key] || mapping.right[key.toLowerCase()] || mapping.right[code];
        if (actionR) registerChoice("right", actionR);
      }
      if (state.choices.left && state.choices.right) resolveRound();
    }

    function toggleDebug(force) {
      debugEnabled = typeof force === "boolean" ? force : !debugEnabled;
      camEl.style.display = debugEnabled ? "block" : "none";
      camEl.style.position = "fixed";
      camEl.style.right = "10px";
      camEl.style.top = "10px";
      camEl.style.width = "240px";
      camEl.style.borderRadius = "10px";
      camEl.style.boxShadow = "0 8px 20px rgba(0,0,0,0.35)";
      camEl.style.pointerEvents = "none";
      debugEl.style.display = debugEnabled ? "block" : "none";
      updateDebugPanel();
      config.showDebug = debugEnabled;
      saveConfig();
    }

    function resetGame(showStart = false) {
      state.scores = { left: 0, right: 0 };
      state.charges = { left: 0, right: 0 };
      state.choices = { left: null, right: null };
      state.shieldWhiffs = { left: 0, right: 0 };
      state.shieldLocked = { left: false, right: false };
      state.health = { left: 1, right: 1 };
      state.boost = {
        left: { gauge: 0, ready: false },
        right: { gauge: 0, ready: false },
      };
      state.headgear = { left: config.headgear?.left || 0, right: config.headgear?.right || 0 };
      state.waitingReturn = false;
      state.roundOpen = false;
      state.sequenceRunning = false;
      state.winner = null;
      state.history = [];
      timeScale = 1;
      clearTimeout(state.timerId);
      clearTimeout(cpuTimeout);
      clearTimeout(nextRoundTimeout);
      callEl.textContent = "";
      statusEl.textContent = "3 ‚Üí 2 ‚Üí 1 ‚Üí 3ÁßíÂÖ•Âäõ";
      resetPlayersPose();
      // Ensure any leftover headgear meshes are cleared/reapplied to match current config.
      attachHeadgear(leftPlayer, state.headgear.left, -1);
      attachHeadgear(rightPlayer, state.headgear.right, 1);
      refreshUI(true);
      hideShields();
      if (showStart) {
        state.mode = null;
        camFocusTargetX = 0;
        camDistTarget = 9.6;
        startScreen.style.display = "flex";
      }
    }

    function handleVisuals(visuals) {
      hideShields();
      if (visuals.left === "gun") {
        const shots = visuals.burstLeft ? 3 : 1;
        for (let i = 0; i < shots; i++) {
          const willHit = visuals.hitRight && i === 0;
          setTimeout(() => spawnBullet(true, willHit, visuals.burstLeft), i * 90);
        }
        if (sounds.shot) { sounds.shot.currentTime = 0; sounds.shot.play(); }
        focusOn((leftPlayer.position.x + rightPlayer.position.x) * 0.5, 0.5, 8.8);
      }
      if (visuals.right === "gun") {
        const shots = visuals.burstRight ? 3 : 1;
        for (let i = 0; i < shots; i++) {
          const willHit = visuals.hitLeft && i === 0;
          setTimeout(() => spawnBullet(false, willHit, visuals.burstRight), i * 90);
        }
        if (sounds.shot) { sounds.shot.currentTime = 0; sounds.shot.play(); }
        focusOn((leftPlayer.position.x + rightPlayer.position.x) * 0.5, 0.5, 8.8);
      }
      if (visuals.left === "shield") {
        showShield(leftPlayer, true, visuals.perfectShieldLeft, state.shieldLocked.left);
        if (visuals.perfectShieldLeft && !state.shieldLocked.left) applyMembrane(leftPlayer, 2200);
        if (!state.shieldLocked.left && visuals.perfectShieldLeft) spawnLightningParry(leftPlayer); else if (!state.shieldLocked.left) spawnIceBarrier(leftPlayer);
        focusOn(leftPlayer.position.x, 0.4, 9.0);
      }
      if (visuals.right === "shield") {
        showShield(rightPlayer, false, visuals.perfectShieldRight, state.shieldLocked.right);
        if (visuals.perfectShieldRight && !state.shieldLocked.right) applyMembrane(rightPlayer, 2200);
        if (!state.shieldLocked.right && visuals.perfectShieldRight) spawnLightningParry(rightPlayer); else if (!state.shieldLocked.right) spawnIceBarrier(rightPlayer);
        focusOn(rightPlayer.position.x, 0.4, 9.0);
      }
     if (visuals.chargeLeft) { spawnChargeRain(leftPlayer); spawnChargeGlow(leftPlayer); }
     if (visuals.chargeRight) { spawnChargeRain(rightPlayer); spawnChargeGlow(rightPlayer); }
      if (visuals.hitLeft) {
        if (state.shieldLocked.left) flashLockedTint(leftPlayer); // flash angry red when locked and hit
        addStain(leftPlayer);
        spawnStars(leftPlayer.position.clone().add(new THREE.Vector3(0, 1.4, 0)), 5);
        focusOn(leftPlayer.position.x, 0.8, 12.0);
        if (sounds.hit) { sounds.hit.currentTime = 0; sounds.hit.play(); }
      }
      if (visuals.hitRight) {
        if (state.shieldLocked.right) flashLockedTint(rightPlayer);
        addStain(rightPlayer);
        spawnStars(rightPlayer.position.clone().add(new THREE.Vector3(0, 1.4, 0)), 5);
        focusOn(rightPlayer.position.x, 0.8, 12.0);
        if (sounds.hit) { sounds.hit.currentTime = 0; sounds.hit.play(); }
      }
      movePlayers(visuals);
    }

    function scheduleResetAfterHit() {
      clearTimeout(nextRoundTimeout);
      camDistTarget = 12.5;
      camFocusTargetX = 0;
      callEl.classList.remove("call-pop");
      void callEl.offsetWidth;
      callEl.classList.add("call-pop");
      nextRoundTimeout = setTimeout(() => {
        resetPlayersPose();
        camFocusTargetX = 0;
        camDistTarget = 9.6;
        callEl.textContent = "NEXT";
        callEl.classList.remove("call-pop");
        void callEl.offsetWidth;
        callEl.classList.add("call-pop");
        setTimeout(() => startSequence(), 500);
      }, 1800);
    }

    function scheduleCpuChoice(immediate = true) {
      clearTimeout(cpuTimeout);
      const delay = immediate ? 0 : 0;
      cpuTimeout = setTimeout(() => {
        if (!state.roundOpen || state.winner) return;
        const hasCharge = state.charges.right > 0;
        const oppHasCharge = state.charges.left > 0;
      const lastOppCharge = state.choices.left === "charge";
      const opponentIdleShots = state.charges.left === 0;
        let choice = "charge";
        if (state.cpuMode === "smart") {
          const weights = { charge: 0.4, gun: 0.4, guard: 0.2 };
          if (!oppHasCharge) weights.guard = 0.05;
          if (lastOppCharge) weights.guard += 0.2;
          if (state.choices.left === "gun") weights.guard += 0.25;
          if (opponentIdleShots) weights.gun += 0.15;
          if (hasCharge) weights.gun += 0.2;
          const roll = Math.random();
          const sum = weights.charge + weights.gun + weights.guard;
          let acc = 0;
          const pick = (key) => { choice = key; };
          acc += weights.charge / sum; if (roll <= acc) pick("charge");
          else if (roll <= acc + weights.gun / sum) pick("gun");
          else pick("guard");
        } else if (state.cpuMode === "ultra") {
          // weighted strategy based on imported weights
          const w = config.cpuWeights || { charge: 0.33, gun: 0.33, guard: 0.34 };
          const sum = w.charge + w.gun + w.guard || 1;
          const roll = Math.random();
          let acc = 0;
          acc += w.charge / sum;
          if (roll <= acc) choice = "charge";
          else if (roll <= acc + w.gun / sum) choice = "gun";
          else choice = "guard";
          if (choice === "guard" && state.shieldLocked.right) choice = hasCharge ? "gun" : "charge";
        } else {
          if (Math.random() < 0.2) choice = "guard";
          if (hasCharge && Math.random() < 0.7) choice = "gun";
        }
        if (choice === "guard" && state.shieldLocked.right) choice = "charge";
        registerChoice("right", choice);
        if (state.choices.left && state.choices.right) resolveRound();
      }, delay);
    }

    // Camera/gesture input
    const HAND_CONNECTIONS = [
      [0,1],[1,2],[2,3],[3,4], // thumb
      [0,5],[5,6],[6,7],[7,8], // index
      [5,9],[9,10],[10,11],[11,12], // middle
      [9,13],[13,14],[14,15],[15,16], // ring
      [13,17],[17,18],[18,19],[19,20], // pinky
      [0,17]
    ];
    function initCamera() {
      if (cameraReady) return;
      const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
      });
      hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6,
      });
      hands.onResults(onHands);
      const cam = new Camera(camEl, {
        onFrame: async () => {
          await hands.send({ image: camEl });
        },
        width: 640,
        height: 480,
      });
      cam.start();
      cameraReady = true;
    }

    function onHands(results) {
      if (config.inputMode !== "hand") {
        gestures.left = null;
        gestures.right = null;
        updateDebugPanel();
        drawDebugHands(null, null);
        return;
      }
      debugState.left = null;
      debugState.right = null;
      if (!results.multiHandLandmarks || !results.multiHandedness) {
        updateGesturesFromCache();
        updateDebugPanel();
        drawDebugHands(null, null);
        return;
      }
      let bestLeft = null;
      let recognizedIdx = new Set();
      results.multiHandLandmarks.forEach((lm, idx) => {
        const hand = results.multiHandedness[idx];
        const side = detectSideByPosition(lm); // screen positionÂÑ™ÂÖà„ÅßÂ∑¶Âè≥„ÇíÊ±∫„ÇÅ„Çã
        const detail = classifyGestureDetail(lm, hand.label);
        const now = performance.now();
        gestureCache[side] = { gesture: detail.gesture, time: now };
        if (state.mode === "cpu") {
          if (!bestLeft || detail.span > bestLeft.span) bestLeft = { gesture: detail.gesture, span: detail.span, detail, idx };
        } else {
          gestures[side] = detail.gesture;
          debugState[side] = detail;
          recognizedIdx.add(idx);
        }
      });
      if (state.mode === "cpu" && bestLeft) {
        gestures.left = bestLeft.gesture;
        debugState.left = bestLeft.detail;
        recognizedIdx.add(bestLeft.idx);
      } else {
        updateGesturesFromCache();
      }
      if (state.roundOpen) {
        if (gestures.left) registerChoice("left", gestures.left);
        if (gestures.right) registerChoice("right", gestures.right);
        if (state.choices.left && state.choices.right) resolveRound();
      }
      updateDebugPanel();
      drawDebugHands(results, recognizedIdx);
    }

    function handSpan(lm) {
      const xs = lm.map((p) => p.x);
      const ys = lm.map((p) => p.y);
      return (Math.max(...xs) - Math.min(...xs)) + (Math.max(...ys) - Math.min(...ys));
    }

    function classifyGestureDetail(lm, handedness) {
      const span = handSpan(lm);
      const extended = fingerStates(lm, handedness, span);
      const extendedCount = Object.values(extended).filter(Boolean).length;
      const bigSpanOpen = span > 0.32; // spread wide => treat as open hand
      const gunShape = extended.index && !extended.ring && !extended.pinky && (extended.thumb || !extended.middle || (extended.middle && span < 0.35)); // ÊåáÂ∑Æ„Åó/„ÉÅ„Éß„Ç≠Ë®±ÂÆπ
      const openHand = extendedCount >= 3 || (extendedCount >= 2 && span > 0.3) || bigSpanOpen; // „Éë„ÉºÂà§ÂÆö„Åï„Çâ„Å´Á∑©„ÇÅ
      const gesture = openHand ? "shield" : gunShape ? "gun" : "charge";
      return { gesture, extended, span: Number(span.toFixed(3)) };
    }

    function fingerStates(lm, handedness, span = 0.2) {
      const margin = span * 0.03 + 0.016; // more forgiving for stretched fingers
      const wrist = lm[0];
      const isExtended = (tip, pip, mcp) => {
        const vertical = lm[tip].y + margin < lm[pip].y;
        const lifted = lm[tip].y + margin < lm[mcp].y;
        return vertical || lifted;
      };
      const index = isExtended(8, 6, 5);
      const middle = isExtended(12, 10, 9);
      const ring = isExtended(16, 14, 13);
      const pinky = isExtended(20, 18, 17);
      const thumbTip = lm[4], thumbIP = lm[3], thumbMCP = lm[2];
      const thumbXOpen = handedness === "Right"
        ? thumbTip.x + margin < thumbIP.x && thumbTip.x + margin < thumbMCP.x
        : thumbTip.x - margin > thumbIP.x && thumbTip.x - margin > thumbMCP.x;
      const thumbAway = Math.abs(thumbTip.y - wrist.y) < 0.2 || Math.abs(thumbTip.x - wrist.x) > 0.08;
      const thumb = thumbXOpen || thumbAway;
      return { thumb, index, middle, ring, pinky };
    }

    function detectSideByPosition(lm) {
      const avgX = lm.reduce((s, p) => s + p.x, 0) / lm.length;
      // camera feed is mirrored, so flip the screen side to real side
      return avgX < 0.5 ? "right" : "left";
    }

    function updateGesturesFromCache() {
      const now = performance.now();
      const hold = 220; // ms hold to bridge dropped frames
      ["left", "right"].forEach((side) => {
        const cached = gestureCache[side];
        if (cached && now - cached.time <= hold) {
          gestures[side] = cached.gesture;
        } else {
          gestures[side] = null;
        }
      });
    }

    function updateDebugPanel() {
      if (!debugEnabled) return;
      const fmt = (side) => {
        const d = debugState[side];
        if (!d) return "„Å™„Åó";
        const f = d.extended;
        const flags = `T:${f.thumb ? 1 : 0} I:${f.index ? 1 : 0} M:${f.middle ? 1 : 0} R:${f.ring ? 1 : 0} P:${f.pinky ? 1 : 0}`;
        return `${d.gesture} span:${d.span} ${flags}`;
      };
      debugEl.textContent = `mode:${state.mode || "-"}\nleft:${fmt("left")}\nright:${fmt("right")}`;
    }

    function drawDebugHands(results, recognizedIdx) {
      const w = debugCanvas.width = window.innerWidth;
      const h = debugCanvas.height = window.innerHeight;
      debugCtx.clearRect(0, 0, w, h);
      if (!results || !results.multiHandLandmarks) return;
      results.multiHandLandmarks.forEach((lm, idx) => {
        const recognized = recognizedIdx && recognizedIdx.has(idx);
        const color = recognized ? "rgba(0,255,0,0.9)" : "rgba(255,255,255,0.45)";
        HAND_CONNECTIONS.forEach(([a, b]) => {
          const pa = lm[a], pb = lm[b];
          debugCtx.strokeStyle = color;
          debugCtx.lineWidth = recognized ? 4 : 2;
          debugCtx.beginPath();
          debugCtx.moveTo(pa.x * w, pa.y * h);
          debugCtx.lineTo(pb.x * w, pb.y * h);
          debugCtx.stroke();
        });
      });
    }

    function flashLockedTint(player, duration = 400) {
      const tint = new THREE.Color(0xff0000);
      // Avoid reapplying while active
      if (player.userData.lockTintActive) { spawnLockX(player); return; }
      player.userData.lockTintActive = true;
      spawnLockX(player);
      player.traverse((child) => {
        if (!child.isMesh || !child.material) return;
        const mat = child.material;
        const supported = mat.isMeshStandardMaterial || mat.isMeshPhongMaterial || mat.isMeshToonMaterial || mat.isMeshLambertMaterial;
        if (!supported) return;
        if (!mat.emissive) mat.emissive = new THREE.Color(0x000000);
        if (!child.material.userData.__origEmissive) {
          mat.userData.__origEmissive = mat.emissive.clone();
          mat.userData.__origIntensity = mat.emissiveIntensity || 0;
        }
        mat.emissive.copy(tint);
        mat.emissiveIntensity = 2.5;
      });
      setTimeout(() => {
        player.traverse((child) => {
          if (!child.isMesh || !child.material) return;
          const mat = child.material;
          const supported = mat.isMeshStandardMaterial || mat.isMeshPhongMaterial || mat.isMeshToonMaterial || mat.isMeshLambertMaterial;
          if (!supported) return;
          const data = mat.userData;
          if (data?.__origEmissive) {
            mat.emissive.copy(data.__origEmissive);
            mat.emissiveIntensity = data.__origIntensity || 0;
          }
        });
        player.userData.lockTintActive = false;
      }, duration);
    }

    function spawnLockX(player) {
      const layer = document.getElementById("lock-x-layer");
      if (!layer) return;
      const head = player.getObjectByName("headAnchor");
      const pos = head ? head.getWorldPosition(new THREE.Vector3()) : player.position.clone();
      pos.y += 0.9;
      const screen = worldToScreen(pos);
      const el = document.createElement("div");
      el.className = "red-x";
      el.textContent = "‚úï";
      el.style.left = `${screen.x}px`;
      el.style.top = `${screen.y}px`;
      layer.appendChild(el);
      setTimeout(() => el.remove(), 500);
    }

    function showShield(player, isLeft, perfect = false, locked = false) {
      const shield = player.getObjectByName("shield");
      if (!shield) return;
      shield.visible = true;
      if (locked) {
        flashLockedTint(player);
      } else {
        applyMembrane(player, perfect ? 2200 : 1500);
      }
      setTimeout(() => { shield.visible = false; }, 1500);
      if (isLeft) player.rotation.y = 0.12;
      else player.rotation.y = -0.12;
      setTimeout(() => { player.rotation.y = 0; }, 400);
      spawnGuardWave(player);
    }

    function hideShields() {
      leftPlayer.getObjectByName("shield").visible = false;
      rightPlayer.getObjectByName("shield").visible = false;
    }

    function spawnGuardWave(player) {
      const ring = new THREE.Mesh(
        new THREE.RingGeometry(0.6, 0.9, 24),
        new THREE.MeshBasicMaterial({ color: 0x7bf0ff, transparent: true, opacity: 0.8, side: THREE.DoubleSide })
      );
      ring.rotation.x = -Math.PI / 2;
      ring.position.copy(player.position);
      ring.position.y = 1;
      ring.userData = { life: 0.8, scale: 0.8 };
      scene.add(ring);
      guards.push(ring);
      spawnHoneycombBurst(player);
      spawnStreaks(player);
      camShake = Math.max(camShake, 0.12); // light shake on guard
    }

    function movePlayers(visuals) {
      leftPlayer.userData.targetX = leftPlayer.userData.baseX;
      rightPlayer.userData.targetX = rightPlayer.userData.baseX;
      if (visuals.left === "gun") leftPlayer.userData.targetX += 0.4;
      if (visuals.right === "gun") rightPlayer.userData.targetX -= 0.4;
      if (visuals.left === "shield") leftPlayer.userData.targetX -= 0.25;
      if (visuals.right === "shield") rightPlayer.userData.targetX += 0.25;
    }

    function knockOffHeadgear(player, side, hatId) {
      if (!player) return;
      const anchor = player.getObjectByName("headAnchor");
      if (!anchor || anchor.children.length === 0) return;
      const hat = anchor.children.pop();
      anchor.remove(hat);
      const worldPos = new THREE.Vector3();
      anchor.getWorldPosition(worldPos);
      hat.position.copy(worldPos);
      spawnStars(worldPos, 4);
      const dir = player.userData.lastHitDir ?? (side === "left" ? -1 : 1);
      hat.userData.spin = new THREE.Vector3(
        (Math.random() - 0.5) * 8 * HEADGEAR_KNOCK_SPEED,
        (4 + Math.random() * 4) * HEADGEAR_KNOCK_SPEED,
        (Math.random() - 0.5) * 8 * HEADGEAR_KNOCK_SPEED
      );
      hat.userData.vel = new THREE.Vector3(
        dir * (0.8 + Math.random() * 0.6) * 10,
        (9.5 + Math.random() * 3.5) * 10,
        (Math.random() - 0.5) * 0.8 * 10
      );
      hat.userData.gravity = 20;
      hat.userData.life = 0.6;
      hat.userData.returning = true; // immediately mark for removal on update
      hat.userData.anchor = anchor;
      hat.userData.startRot = hat.rotation.clone();
      hat.userData.hatId = hatId || hat.userData.hatId;
      knockedHats.push(hat);
      scene.add(hat);
      if (hat.userData.hatId === 1) spawnLemonSplash(hat.position);
      if (hat.userData.hatId === 3) spawnHeadphoneRipple(hat.position);
      if (hat.userData.hatId === 2) spawnCrownSparkle(hat.position);
    }

    function easeInOutQuad(t) {
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }

    let hexGeom = null;
    function spawnHoneycombBurst(player) {
      const base = player.position.clone().add(new THREE.Vector3(0, 1.2, 0.4));
      if (!hexGeom) {
        const shape = new THREE.Shape();
        const r = 0.18;
        for (let i = 0; i < 6; i++) {
          const a = (Math.PI / 3) * i + Math.PI / 6;
          const x = Math.cos(a) * r, y = Math.sin(a) * r;
          if (i === 0) shape.moveTo(x, y); else shape.lineTo(x, y);
        }
        shape.closePath();
        hexGeom = new THREE.ShapeGeometry(shape);
      }
      const count = 10;
      for (let i = 0; i < count; i++) {
        const mesh = new THREE.Mesh(
          hexGeom,
          new THREE.MeshBasicMaterial({ color: 0x35e0ff, transparent: true, opacity: 0.9, side: THREE.DoubleSide, depthWrite: false })
        );
        mesh.position.copy(base).add(new THREE.Vector3(
          (Math.random() - 0.5) * 1.2,
          (Math.random() - 0.5) * 0.6,
          (Math.random() - 0.5) * 0.6
        ));
        mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        mesh.userData = {
          vel: new THREE.Vector3((Math.random() - 0.5) * 3, (Math.random() - 0.2) * 2, (Math.random() - 0.5) * 2),
          life: 0.4,
          start: 0.4,
          spin: new THREE.Vector3(Math.random() * 4, Math.random() * 4, Math.random() * 4),
        };
        scene.add(mesh);
        honeycombs.push(mesh);
      }
    }

    function spawnStreaks(player) {
      const base = player.position.clone().add(new THREE.Vector3(0, 1.0, -0.2));
      const count = 4;
      for (let i = 0; i < count; i++) {
        const geom = new THREE.PlaneGeometry(0.05, 0.8);
        const streak = new THREE.Mesh(
          geom,
          new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6, side: THREE.DoubleSide, depthWrite: false })
        );
        streak.position.copy(base).add(new THREE.Vector3(
          (Math.random() - 0.5) * 0.4,
          (Math.random() - 0.5) * 0.3,
          -0.1
        ));
        streak.rotation.y = Math.PI; // point backward
        streak.rotation.x = Math.PI / 2;
        streak.userData = { life: 0.2, start: 0.2 };
        scene.add(streak);
        streaks.push(streak);
      }
    }

    function spawnChargeGlow(player) {
      const glow = new THREE.Mesh(
        new THREE.RingGeometry(0.9, 1.2, 24),
        new THREE.MeshBasicMaterial({ color: 0x00aaff, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
      );
      glow.position.copy(player.position);
      glow.position.y = 1.2;
      glow.rotation.x = -Math.PI / 2;
      glow.userData = { t: 0, life: 0.6 };
      scene.add(glow);
      chargeGlows.push(glow);
    }

    function spawnChargeShockwave(player) {
      const wave = new THREE.Mesh(
        new THREE.RingGeometry(0.8, 1.6, 32),
        new THREE.MeshBasicMaterial({ color: 0xff66ff, transparent: true, opacity: 0.7, side: THREE.DoubleSide })
      );
      wave.position.copy(player.position);
      wave.position.y = 1.1;
      wave.rotation.x = -Math.PI / 2;
      wave.userData = { life: 0.4, start: 0.4 };
      scene.add(wave);
      chargeGlows.push(wave);
    }

    function spawnDamageTrail(player, dir, side) {
      const trailSide = side || (player === leftPlayer ? "left" : "right");
      const existing = damageTrails.find((t) => t.userData.side === trailSide);
      const start = existing?.userData.startPos || player.position.clone().add(new THREE.Vector3(0, 1.2, 0.1));
      const end = player.position.clone().add(new THREE.Vector3(0, 1.2, 0.1)).add(new THREE.Vector3(dir * -2.6, 0, 0));
      const mid = start.clone().lerp(end, 0.5);
      const length = start.distanceTo(end);
      const dirVec = end.clone().sub(start).normalize();

      let trail = existing;
      if (!trail) {
        const geom = new THREE.BoxGeometry(length, 0.16, 0.04);
        const mat = new THREE.MeshBasicMaterial({ color: 0xff3030, transparent: true, opacity: 0.9, depthWrite: false });
        trail = new THREE.Mesh(geom, mat);
        trail.userData = { side: trailSide, startPos: start.clone(), life: 0.2, start: 0.2 };
        scene.add(trail);
        damageTrails.push(trail);
      } else {
        if (trail.geometry) trail.geometry.dispose();
        trail.geometry = new THREE.BoxGeometry(length, 0.16, 0.04);
        trail.userData.startPos = start.clone();
        trail.userData.life = trail.userData.start = 0.2;
      }
      trail.position.copy(mid);
      trail.quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), dirVec);
    }

    function spawnIceBarrier(player) {
      const wall = new THREE.Mesh(
        new THREE.PlaneGeometry(1.8, 1.6),
        new THREE.MeshBasicMaterial({ color: 0x7be7ff, transparent: true, opacity: 0.6, side: THREE.DoubleSide })
      );
      wall.position.copy(player.position).add(new THREE.Vector3(0, 1.2, 0.6));
      wall.rotation.y = Math.PI / 2;
      wall.userData = { life: 0.35, start: 0.35 };
      scene.add(wall);
      barriers.push(wall);
    }

    function spawnLightningParry(player) {
      const wave = new THREE.Mesh(
        new THREE.RingGeometry(0.4, 1.2, 20, 1, 0, Math.PI * 2),
        new THREE.MeshBasicMaterial({ color: 0xb855ff, transparent: true, opacity: 0.9, side: THREE.DoubleSide })
      );
      wave.position.copy(player.position);
      wave.position.y = 1.3;
      wave.rotation.x = -Math.PI / 2;
      wave.userData = { life: 0.25, start: 0.25 };
      scene.add(wave);
      barriers.push(wave);
    }

    function spawnWinConfetti(player) {
      const base = player.position.clone();
      base.y = 2.4;
      for (let i = 0; i < 20; i++) {
        const piece = new THREE.Mesh(
          new THREE.PlaneGeometry(0.12, 0.18),
          new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xfff280 : 0xff7be0, transparent: true, opacity: 0.9, side: THREE.DoubleSide })
        );
        piece.position.copy(base).add(new THREE.Vector3(
          (Math.random() - 0.5) * 2,
          Math.random() * 0.8,
          (Math.random() - 0.5) * 2
        ));
        piece.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        piece.userData = { vel: new THREE.Vector3((Math.random() - 0.5) * 1.5, 1 + Math.random(), (Math.random() - 0.5) * 1.5), life: 1.0, start: 1.0 };
        scene.add(piece);
        confettis.push(piece);
      }
    }

    function spawnLemonSplash(pos) {
      for (let i = 0; i < 8; i++) {
        const drop = new THREE.Mesh(
          new THREE.SphereGeometry(0.06, 10, 10),
          new THREE.MeshBasicMaterial({ color: 0xffd740, transparent: true, opacity: 0.9 })
        );
        drop.position.copy(pos);
        drop.userData = { vel: new THREE.Vector3((Math.random() - 0.5) * 2, Math.random() * 2, (Math.random() - 0.5) * 2), life: 0.5, start: 0.5 };
        scene.add(drop);
        stars.push(drop);
      }
    }

    function spawnHeadphoneRipple(pos) {
      const ripple = new THREE.Mesh(
        new THREE.RingGeometry(0.2, 0.5, 20),
        new THREE.MeshBasicMaterial({ color: 0x66a8ff, transparent: true, opacity: 0.8, side: THREE.DoubleSide })
      );
      ripple.position.copy(pos);
      ripple.position.y += 0.3;
      ripple.rotation.x = -Math.PI / 2;
      ripple.userData = { life: 0.3, start: 0.3 };
      scene.add(ripple);
      barriers.push(ripple);
    }

    function spawnCrownSparkle(pos) {
      const sparkle = new THREE.Mesh(
        new THREE.PlaneGeometry(0.4, 0.4),
        new THREE.MeshBasicMaterial({ color: 0xfff2a0, transparent: true, opacity: 1, side: THREE.DoubleSide })
      );
      sparkle.position.copy(pos);
      sparkle.position.y += 0.3;
      sparkle.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
      sparkle.userData = { life: 0.25, start: 0.25 };
      scene.add(sparkle);
      confettis.push(sparkle);
    }

    let starGeom = null;
    function spawnStars(worldPos, count = 3 + Math.floor(Math.random() * 3)) {
      if (!starGeom) {
        const shape = new THREE.Shape();
        const spikes = 5;
        const outer = 0.16;
        const inner = 0.07;
        for (let i = 0; i < spikes * 2; i++) {
          const r = i % 2 === 0 ? outer : inner;
          const a = (i / (spikes * 2)) * Math.PI * 2 - Math.PI / 2;
          if (i === 0) shape.moveTo(Math.cos(a) * r, Math.sin(a) * r);
          else shape.lineTo(Math.cos(a) * r, Math.sin(a) * r);
        }
        shape.closePath();
        starGeom = new THREE.ShapeGeometry(shape);
      }
      for (let i = 0; i < count; i++) {
        const star = new THREE.Mesh(
          starGeom,
          new THREE.MeshBasicMaterial({ color: 0xffe566, transparent: true, opacity: 1, side: THREE.DoubleSide, depthWrite: false })
        );
        star.position.copy(worldPos).add(new THREE.Vector3(
          (Math.random() - 0.5) * 0.4,
          Math.random() * 0.2,
          (Math.random() - 0.5) * 0.4
        ));
        star.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        star.userData = {
          vel: new THREE.Vector3((Math.random() - 0.5) * 2, 2 + Math.random() * 2, (Math.random() - 0.5) * 2),
          life: 0.6,
          start: 0.6,
          spin: new THREE.Vector3(Math.random() * 2, Math.random() * 2, Math.random() * 2),
        };
        scene.add(star);
        stars.push(star);
      }
    }

    let camPhase = 0;
    let camShake = 0;
    let timeScale = 1;
    let camFocusX = 0;
    let camFocusTargetX = 0;
    let camDist = 9.6;
    let camDistTarget = 9.6;
    let camOrbit = 0;
    const gravity = 14;
    function worldToScreen(vec3) {
      const pos = vec3.clone().project(camera);
      return {
        x: (pos.x + 1) / 2 * window.innerWidth,
        y: (-pos.y + 1) / 2 * window.innerHeight,
      };
    }

    function ensureShieldMeterGroup(player) {
      let group = player.getObjectByName("shieldMeterGroup");
      if (!group) {
        group = new THREE.Group();
        group.name = "shieldMeterGroup";
        player.add(group);
      }
      return group;
    }

    function rebuildShieldMeter(group, pct, locked) {
      while (group.children.length) {
        const c = group.children.pop();
        if (c.geometry) c.geometry.dispose();
        group.remove(c);
      }
      const arc = locked ? Math.PI * 2 : Math.max(0.001, pct * Math.PI * 2);
      const ringMat = new THREE.MeshToonMaterial({
        color: locked ? 0x52c7ff : 0x23f3ff,
        emissive: locked ? new THREE.Color(0x1f6fa0) : new THREE.Color(0x0ad8ff),
        emissiveIntensity: 0.9,
        transparent: true,
        opacity: locked ? 0.7 : 0.95,
        side: THREE.DoubleSide,
      });
      const ring = new THREE.Mesh(new THREE.RingGeometry(0.35, 0.52, 64, 1, -Math.PI / 2, arc), ringMat);
      ring.name = "shieldMeterRing";
      const outline = makeOutline(ring, 1.06, "head"); // use headgear-style outline for readability
      group.add(ring);
      group.add(outline);
    }

    function updateShieldMeters() {
      const max = SHIELD_MAX_WHIFTS;
      const update = (player, side) => {
        if (!player) return;
        const group = ensureShieldMeterGroup(player);
        const locked = !!state.shieldLocked[side];
        const whiffs = state.shieldWhiffs[side] || 0;
        const remaining = locked ? 0 : Math.max(0, max - whiffs);
        const pct = max ? remaining / max : 0;
        rebuildShieldMeter(group, pct, locked);
        const dir = side === "left" ? -1 : 1;
        // Local offset so we don't double-apply world transforms
        group.position.set(dir * 2, 3.5, 0);
        group.lookAt(camera.position.x, player.position.y + group.position.y, camera.position.z);
        group.visible = player.visible;
      };
      update(leftPlayer, "left");
      update(rightPlayer, "right");
    }

    function updateHealthUI() {
      const update = (juiceEl, value) => {
        if (!juiceEl) return;
        const clamped = Math.max(0, Math.min(1, value));
        juiceEl.style.setProperty("--juice", clamped);
        juiceEl.style.height = `${clamped * 100}%`;
        juiceEl.classList.toggle("low", clamped <= 0.35);
      };
      update(juiceLeft, state.health.left);
      update(juiceRight, state.health.right);
    }

    function updateBoostUI() {
      const max = BOOST_MAX;
      const update = (pill, fill, side, player, offsetX) => {
        if (!pill || !fill || !player) return;
        if (!player.visible) {
          pill.style.display = "none";
          return;
        }
        const gauge = state.boost[side]?.gauge || 0;
        const ready = !!state.boost[side]?.ready;
        const pct = Math.min(1, gauge / max) * 100;
        fill.style.height = `${pct}%`;
        pill.classList.toggle("ready", ready);
        const anchor = player.position.clone().add(new THREE.Vector3(offsetX, 2.2, 0));
        const screen = worldToScreen(anchor);
        pill.style.left = `${screen.x}px`;
        pill.style.top = `${screen.y - 60}px`;
        pill.style.display = "block";
      };
      update(boostPillLeft, boostFillLeft, "left", leftPlayer, -1.2);
      update(boostPillRight, boostFillRight, "right", rightPlayer, 1.2);
    }

    function makeOutline(mesh, scale = 1.06, kind = "player") {
      const outline = mesh.clone();
      const isPlayer = kind === "player";
      outline.material = new THREE.MeshBasicMaterial({
        color: 0x000000,
        side: isPlayer ? THREE.DoubleSide : THREE.BackSide, // player only: inner+outer lines
        depthWrite: false,
        depthTest: true,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1,
      });
      const factor = kind === "head" ? OUTLINE_SCALE_HEAD : OUTLINE_SCALE_PLAYER;
      outline.scale.multiplyScalar(scale * factor * OUTLINE_SCALE_GLOBAL);
      // Keep outlines behind their meshes but still above ground (ground depthWrite is off)
      outline.renderOrder = -0.5;
      return outline;
    }

    function makeHeadgearMesh(id, sideDir) {
      const group = new THREE.Group();
      const toonMaterial = (color, emissive = 0x000000, emissiveIntensity = 0.6) =>
        new THREE.MeshToonMaterial({ color, gradientMap: null, emissive, emissiveIntensity });
      switch (id) {
        case 1: { // „É¨„É¢„É≥„Ç≠„É£„ÉÉ„ÉóÔºàÂæìÊù•Ôºâ
          const rim = new THREE.Mesh(new THREE.CylinderGeometry(0.68, 0.68, 0.12, 18), toonMaterial(0xffd740));
          rim.position.y = -0.08;
          group.add(rim);
          group.add(makeOutline(rim, 1.06, "head"));
          const dome = new THREE.Mesh(new THREE.SphereGeometry(1, 10, 10), toonMaterial(0xffd740));
          dome.position.y = 0.15;
          dome.scale.set(1.0, 0.6, 1.0);
          group.add(dome);
          group.add(makeOutline(dome, 1.06, "head"));
          const leaf = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 0.24), toonMaterial(0x5ac26f));
          leaf.rotation.y = 0.25;
          leaf.rotation.z = 0.25;
          leaf.position.set(0.0, 0.55, 0.3);
          group.add(leaf);
          group.add(makeOutline(leaf, 1.08, "head"));
          break;
        }
        case 2: { // ÁéãÂÜ†ÔºàÂæìÊù•Ôºâ
          const rim = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.11, 18), toonMaterial(0xffd740));
          rim.position.y = -0.06;
          group.add(rim);
          group.add(makeOutline(rim, 1.06, "head"));
          const base = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.5, 0.7, 9, 1, false), toonMaterial(0xffc933));
          base.position.y = -0.08;
          group.add(base);
          group.add(makeOutline(base, 1.06, "head"));
          const coneGeom = new THREE.ConeGeometry(0.45, 1.1, 16);
          const count = 7;
          const radius = 0.35; // center the spikes
          for (let i = 0; i < count; i++) {
            const ang = (Math.PI * 2 * i) / count;
            const cone = new THREE.Mesh(coneGeom, toonMaterial(0xffd84d));
            cone.position.set(Math.cos(ang) * radius, 0.35, Math.sin(ang) * radius);
            const outward = new THREE.Vector3(Math.cos(ang), 2, Math.sin(ang)).normalize(); // tilt outward from center
            cone.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), outward);
            group.add(cone);
            group.add(makeOutline(cone, 1.2, "head"));
          }
          break;
        }
        case 3: { // „Éò„ÉÉ„Éâ„Éõ„É≥ÔºàÂæìÊù•Ôºâ
          const band = new THREE.Mesh(new THREE.TorusGeometry(0.85, 0.11, 14, 28, Math.PI), toonMaterial(0x222222));
          band.rotation.x = 0;
          band.rotation.z = 0;
          band.rotation.y = Math.PI / 2;
          band.position.y = -0.4;
          group.add(band);
          const earGeom = new THREE.CylinderGeometry(0.26, 0.26, 0.24, 14);
          const earL = new THREE.Mesh(earGeom, toonMaterial(0x444444));
          earL.rotation.z = Math.PI / 2;
          earL.rotation.y = Math.PI / 2;
          earL.position.set(0, -0.6, 0.8);
          const earR = earL.clone();
          earR.position.z = -0.62;
          group.add(earL, earR);
          group.add(makeOutline(band, 1.06, "head"));
          group.add(makeOutline(earL, 1.06, "head"));
          group.add(makeOutline(earR, 1.06, "head"));
          break;
        }
        case 4: { // „Ç∑„Çß„ÉïÂ∏ΩÔºàÂÜÜÊü±‰∏ª‰ΩìÔºâ
          const band = new THREE.Mesh(new THREE.CylinderGeometry(0.85, 0.85, 0.4, 28), toonMaterial(0xffffff, 0xdddddd, 0.35));
          band.position.y = -0.3;
          group.add(band);
          group.add(makeOutline(band, 1.08, "head"));
          const crown = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 0.8, 1.6, 32), toonMaterial(0xffffff, 0xffffff, 0.25));
          crown.position.y = 0.3;
          group.add(crown);
          group.add(makeOutline(crown, 1.08, "head"));
          break;
        }
        case 5: { // „Ç∑„É´„ÇØ„Éè„ÉÉ„Éà
          const brim = new THREE.Mesh(new THREE.CylinderGeometry(1.0, 1.0, 0.08, 28), toonMaterial(0x111111, 0x0a0a0a, 0.5));
          brim.position.y = -0.3;
          group.add(brim);
          group.add(makeOutline(brim, 1.08, "head"));
          const body = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.82, 0.8, 28), toonMaterial(0x111111, 0x0a0a0a, 0.5));
          body.position.y = 0.12;
          group.add(body);
          group.add(makeOutline(body, 1.06, "head"));
          const ribbon = new THREE.Mesh(new THREE.CylinderGeometry(0.82, 0.84, 0.16, 28), toonMaterial(0xc00021, 0x520010, 0.6));
          ribbon.position.y = -0.2;
          group.add(ribbon);
          group.add(makeOutline(ribbon, 1.05, "head"));
          break;
        }
        case 6: { // „Éò„É´„É°„ÉÉ„Éà
          const shell = new THREE.Mesh(new THREE.SphereGeometry(0.8, 20, 20, 0, Math.PI * 2, 0, Math.PI / 1.4), toonMaterial(0xf5d740, 0x8a6f00, 0.7));
          shell.scale.set(1.05, 1.0, 1.05);
          shell.position.y = -0.1;
          group.add(shell);
          group.add(makeOutline(shell, 1.08, "head"));
          const brim = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 0.9, 0.08, 24), toonMaterial(0xf5d740, 0x8a6f00, 0.7));
          brim.position.set(0, -0.3, -0.05);
          brim.rotation.x = 0.2;
          group.add(brim);
          group.add(makeOutline(brim, 1.06, "head"));
          break;
        }
        case 7: { // „Ç¢„Éã„Éû„É´ËÄ≥
          const earGeom = new THREE.SphereGeometry(0.32, 14, 14);
          const innerGeom = new THREE.SphereGeometry(0.2, 12, 12);
          const placeEar = (sx) => {
            const ear = new THREE.Mesh(earGeom, toonMaterial(0xffffff, 0xdedede, 0.4));
            ear.scale.set(0.7, 2, 0.4);
            ear.position.set(0, 0.35, sx * 0.4);
            const inner = new THREE.Mesh(innerGeom, toonMaterial(0xf5b4c8, 0xe78aaa, 0.4));
            inner.scale.set(0.5, 0.9, 0.3);
            inner.position.set(0, 0, sx * 0.02);
            ear.add(inner);
            group.add(ear);
            group.add(makeOutline(ear, 1.08, "head"));
          };
          placeEar(1);
          placeEar(-1);
          break;
        }
        case 8: { // „Åü„Åæ„ÅîÂØøÂè∏
          const egg = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.6, 1.0, 1, 1, 1), toonMaterial(0xffe16b, 0xf1b300, 0.5));
          egg.position.y = 0;
          group.add(egg);
          group.add(makeOutline(egg, 1.06, "head"));
          const nori = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1, 1.3), toonMaterial(0x0b1720, 0x000000, 0.5));
          nori.position.y = -0.2;
          group.add(nori);
          group.add(makeOutline(nori, 1.08, "head"));
          break;
        }
        case 9: { // „Å≠„Åò„Çä„Éè„ÉÅ„Éû„Ç≠
          const band = new THREE.Mesh(new THREE.TorusGeometry(0.7, 0.16, 20, 48), toonMaterial(0xffffff, 0xdcdcdc, 0.4));
          band.rotation.x = Math.PI / 2;
          band.position.y = -0.3;
          group.add(band);
          group.add(makeOutline(band, 1.08, "head"));
          const stripe = new THREE.Mesh(new THREE.TorusGeometry(0.7, 0.08, 12, 48), toonMaterial(0xffffff, 0xdcdcdc, 0.7));
          stripe.rotation.x = Math.PI / 2;
          stripe.position.y = -0.08;
          stripe.rotation.z = 0.6;
          group.add(stripe);
          group.add(makeOutline(stripe, 1.08, "head"));
          break;
        }
        case 10: { // „Ç´„Ç¶„Éú„Éº„Ç§„Éè„ÉÉ„Éà
          const brim = new THREE.Mesh(new THREE.RingGeometry(0.7, 1.4, 36), toonMaterial(0x8a5a2f, 0x3a2213, 0.5));
          brim.rotation.x = -Math.PI / 2;
          brim.position.y = -0.28;
          group.add(brim);
          group.add(makeOutline(brim, 1.08, "head"));
          const crown = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.8, 0.6, 24), toonMaterial(0x8a5a2f, 0x3a2213, 0.5));
          crown.position.y = 0;
          group.add(crown);
          group.add(makeOutline(crown, 1.06, "head"));
          const dent = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.28, 0.6), toonMaterial(0x7a4d29, 0x2d1b0f, 0.5));
          dent.position.y = 0.15;
          group.add(dent);
          group.add(makeOutline(dent, 1.05, "head"));
          break;
        }
        default:
          break;
      }
      group.position.y = 0.12;
      group.rotation.y = sideDir < 0 ? 0 : Math.PI; // face inward
      group.rotation.x = id === 4 ? 0 : -0.18; // „Ç∑„Çß„ÉïÂ∏Ω„ÅØÂÇæ„Åë„Åö„ÄÅ‰ªñ„ÅØÂ∞ë„ÅóÂâçÂÇæ
      group.scale.set(0.85, 0.85, 0.85);
      return group;
    }

    function attachHeadgear(player, id, sideDir = -1) {
      if (!player) return;
      const anchor = player.getObjectByName("headAnchor");
      if (!anchor) return;
      while (anchor.children.length) anchor.remove(anchor.children.pop());
      if (id && id > 0) {
        const mesh = makeHeadgearMesh(id, sideDir);
        mesh.userData.hatId = id;
        anchor.add(mesh);
      }
    }

    function adjustHealth(side, delta) {
      const next = Math.max(0, Math.min(1, (state.health[side] ?? 1) + delta));
      state.health[side] = next;
      updateHealthUI();
    }

    function updateEyes() {}

    function addBoostCharge(side) {
      const bucket = state.boost[side];
      if (!bucket) return;
      if (bucket.ready) return;
      bucket.gauge = Math.min(BOOST_MAX, (bucket.gauge || 0) + 1);
      if (bucket.gauge >= BOOST_MAX) {
        bucket.ready = true;
        statusEl.textContent = `${side === "left" ? "Â∑¶" : "Âè≥"} CC„Éñ„Éº„Çπ„ÉàÊ∫ñÂÇôOK`;
        if (sounds.charge) { sounds.charge.currentTime = 0; sounds.charge.play(); }
      }
      updateBoostUI();
    }

    function consumeBoost(side) {
      const bucket = state.boost[side];
      if (!bucket) return;
      bucket.gauge = 0;
      bucket.ready = false;
      updateBoostUI();
    }

    function flashScore(side) {
      const target = side === "left" ? scoreLeft : scoreRight;
      if (!target) return;
      target.classList.remove("score-flash");
      void target.offsetWidth;
      target.classList.add("score-flash");
      setTimeout(() => target.classList.remove("score-flash"), 450);
    }

    function spawnScreenFlash() {
      if (PERF.fx !== "high") return;
      if (!fxLayer) return;
      const flash = document.createElement("div");
      flash.className = "fx-flash";
      fxLayer.appendChild(flash);
      setTimeout(() => flash.remove(), 280);
    }


    function spawnImpactAtWorld(vec3) {
      if (PERF.fx !== "high") return;
      const s = worldToScreen(vec3);
      const impact = document.createElement("div");
      impact.className = "fx-impact";
      impact.style.left = `${s.x}px`;
      impact.style.top = `${s.y}px`;
      impact.style.transform += ` rotate(${Math.random() * 40 - 20}deg)`;
      fxLayer.appendChild(impact);
      setTimeout(() => impact.remove(), 420);
    }

    function applyMembrane(player, duration = 600) {
      const highlight = new THREE.Color(0x7bf0ff);
      if (player.userData.membraneTimer) {
        clearTimeout(player.userData.membraneTimer);
      }
      player.traverse((child) => {
        if (!child.isMesh || !child.material) return;
        const mat = child.material;
        const supported = mat.isMeshStandardMaterial || mat.isMeshPhongMaterial || mat.isMeshToonMaterial || mat.isMeshLambertMaterial;
        if (!supported) return; // skip outlines and non-lit materials to avoid invalid uniforms
        if (!mat.userData.__origEmissive) {
          mat.userData.__origEmissive = mat.emissive ? mat.emissive.clone() : new THREE.Color(0x000000);
          mat.userData.__origIntensity = mat.emissiveIntensity || 0;
        }
        if (!mat.emissive) mat.emissive = new THREE.Color(0x000000);
        mat.emissive.copy(highlight);
        mat.emissiveIntensity = 1.0;
      });
      player.userData.membraneTimer = setTimeout(() => {
        player.traverse((child) => {
          if (!child.isMesh || !child.material) return;
          const mat = child.material;
          const supported = mat.isMeshStandardMaterial || mat.isMeshPhongMaterial || mat.isMeshToonMaterial || mat.isMeshLambertMaterial;
          if (!supported) return;
          if (mat.userData.__origEmissive) {
            mat.emissive.copy(mat.userData.__origEmissive);
            mat.emissiveIntensity = mat.userData.__origIntensity || 0;
          }
        });
        player.userData.membraneTimer = null;
      }, duration);
    }


    function spawnSpeedLine(fromLeft) {
      if (PERF.fx !== "high") return;
      if (!fxLayer) return;
      const line = document.createElement("div");
      line.className = "fx-speed";
      const top = 30 + Math.random() * 40;
      const rot = fromLeft ? 5 + Math.random() * 8 : 175 + Math.random() * 8;
      line.style.top = `${top}%`;
      line.style.left = "50%";
      line.style.setProperty("--rot", `${rot}deg`);
      fxLayer.appendChild(line);
      setTimeout(() => line.remove(), 450);
    }

    function updateHandLines() {
      if (lineLeft) lineLeft.style.display = "none";
      if (lineRight) lineRight.style.display = "none";
    }
    function cameraKick(power = 0.6, allowShake = true) {
      camPhase = power;
      camShake = allowShake ? Math.max(camShake, power * 0.28) : 0;
    }

    function focusOn(x, boost = 0.5, dist = 8.8) {
      camFocusTargetX = x;
      camDistTarget = dist;
      cameraKick(boost);
    }
    function isShieldActive(player) {
      const shield = player.getObjectByName("shield");
      return !!(shield && shield.visible);
    }

    function reflectBullet(bullet, defender) {
          const towardOpponentDir = defender.position.x >= 0 ? -1 : 1; // fly diagonally upward toward opponent side
          bullet.userData.dir = towardOpponentDir;
          bullet.userData.upVel = 7;
          bullet.userData.gravity = 10;
          bullet.userData.fromLeft = towardOpponentDir < 0;
          bullet.userData.target = null;
          bullet.userData.willHit = false;
          bullet.userData.life = 1.6;
          if (bullet.userData.outline) bullet.userData.outline.position.copy(bullet.position);
          spawnGuardWave(defender);
          cameraKick(0.4);
        }

    document.addEventListener("keydown", handleKey);
    btn1p.addEventListener("click", () => startMode("cpu"));
    btn2p.addEventListener("click", () => startMode("pvp"));
    btnSettingsStart.addEventListener("click", openSettings);
    floatingSettingsButton.addEventListener("click", openSettings);
    btnSettingsClose.addEventListener("click", closeSettings);
    settingsOverlay.addEventListener("click", (e) => {
      if (e.target === settingsOverlay) closeSettings();
    });
    settingsButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        setInputMode(btn.dataset.inputMode);
        closeSettings();
      });
    });
    cpuButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        state.cpuMode = btn.dataset.cpu;
        cpuButtons.forEach((b) => b.classList.toggle("active", b === btn));
      });
    });
    cpuButtons.forEach((b) => b.classList.toggle("active", b.dataset.cpu === state.cpuMode));
    if (btnReport) {
      btnReport.addEventListener("click", downloadReport);
    }
    const keysRow = document.getElementById("keys");
    if (btnImportWeights && keysRow) {
      keysRow.appendChild(btnImportWeights);
      btnImportWeights.addEventListener("click", () => {
        const input = prompt("„Ç¶„Çß„Ç§„ÉàJSON„ÇíË≤º„Çä‰ªò„Åë (‰æã: {\"charge\":0.3,\"gun\":0.4,\"guard\":0.3})");
        if (!input) return;
        try {
          const obj = JSON.parse(input);
          if (typeof obj.charge === "number" && typeof obj.gun === "number" && typeof obj.guard === "number") {
            config.cpuWeights = { charge: obj.charge, gun: obj.gun, guard: obj.guard };
            saveConfig();
            alert("„Ç¶„Çß„Ç§„Éà„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü„ÄÇË∂Ö„ÅÇ„Åü„Åæ„ÅÑ„ÅÑ„ÅßÈÅ©Áî®„Åï„Çå„Åæ„Åô„ÄÇ");
          } else {
            alert("charge/gun/guard „ÅÆÊï∞ÂÄ§„ÅåÂøÖË¶Å„Åß„Åô");
          }
        } catch (e) {
          alert("JSON„ÅÆÂΩ¢Âºè„Åå‰∏çÊ≠£„Åß„Åô");
        }
      });
    }
    headButtons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const side = btn.dataset.headSide;
        const dir = Number(btn.dataset.dir) || 0;
        setHeadgear(side, dir);
      });
    });
    chkHandLines.addEventListener("change", (e) => toggleHandLines(e.target.checked));
    chkDebug.addEventListener("change", (e) => ensureDebug(e.target.checked));
    refreshUI(true);

    function startMode(mode) {
      state.mode = mode;
      resetGame(false);
      startScreen.style.display = "none";
      camFocusTargetX = 0;
      camDistTarget = 9.6;
      callEl.textContent = "3";
      statusEl.textContent = "";
      state.headgear = { left: config.headgear.left || 0, right: config.headgear.right || 0 };
      attachHeadgear(leftPlayer, state.headgear.left);
      attachHeadgear(rightPlayer, state.headgear.right);
      if (config.inputMode === "hand") initCamera();
      setTimeout(() => startSequence(), 200);
    }

    // Animation loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const raw = clock.getDelta();
      if (hitFreezeTimer > 0) hitFreezeTimer -= raw;
      const localTimeScale = hitFreezeTimer > 0 ? 0.3 : timeScale;
      const delta = raw * localTimeScale;
      // camera sway
      camPhase = Math.max(0, camPhase - delta);
      camShake = Math.max(0, camShake - delta * 2.8);
      camOrbit += delta * 0.35;
      const followLerp = followTarget && followTarget.visible ? 8 : 2.5;
      const distLerp = followTarget && followTarget.visible ? 6 : 2.5;
      camFocusX = THREE.MathUtils.lerp(camFocusX, camFocusTargetX, delta * followLerp);
      camDist = THREE.MathUtils.lerp(camDist, camDistTarget, delta * distLerp);
      const sway = Math.sin(performance.now() * 0.0006) * 0.6;
      const shakeX = (Math.random() - 0.5) * camShake * 0.4;
      const shakeY = (Math.random() - 0.5) * camShake * 0.4;
      const focusX = camFocusX;
      const target = new THREE.Vector3(focusX, 1.4, 0);
      // light camera shake for hits; capped to small offsets
      const shakeMag = 0.02;
      camera.position.x = focusX + sway + Math.sin(camOrbit) * 0.7 + shakeX * shakeMag;
      camera.position.y = 2.4 + Math.sin(camOrbit * 0.8) * 0.15 + camPhase * 0.4 + shakeY * shakeMag;
      camera.position.z = camDist - camPhase * 0.6 + Math.cos(camOrbit) * 0.6;
      camera.lookAt(target);

      // player move lerp / knockback / celebrate
      let flightActive = false;
      [leftPlayer, rightPlayer].forEach((p) => {
        const baseY = -1.2;
        if (p.userData.celebrate && p.userData.celebrate > 0) {
          p.userData.celebrate -= raw;
          const t = performance.now() * 0.002;
          p.position.x = THREE.MathUtils.lerp(p.position.x, p.userData.baseX, delta * 2.5);
          p.position.y = baseY + 0.6 + Math.sin(t * 6) * 0.3;
          p.rotation.y = Math.sin(t * 6) * 0.5;
        } else if (p.userData.knock && p.userData.knock.hold > 0) {
          p.userData.knock.hold -= raw;
          const shake = 0.9;
          const t = performance.now() * 0.001;
          const freq = 60; // 60HzÊåØÂãï
          const wave = Math.sin(2 * Math.PI * freq * t);
          const wave2 = Math.sin(2 * Math.PI * freq * t + Math.PI / 3);
          p.position.x = p.userData.targetX + wave * shake * 1.0;
          p.position.y = baseY + 1.4 + wave2 * shake;
          if (p.userData.knock.hold <= 0) {
            p.userData.kb = p.userData.kb || { x: 0, y: 0 };
            p.userData.kb.x += p.userData.knock.launchX;
            p.userData.kb.y += p.userData.knock.launchY;
            delete p.userData.knock;
          }
        } else if (p.userData.kb) {
          p.userData.kb.y -= gravity * delta;
          p.position.x += p.userData.kb.x * delta;
          p.position.y += p.userData.kb.y * delta;
          p.userData.kb.x = THREE.MathUtils.lerp(p.userData.kb.x, 0, delta * 0.6);
          // leave red trails while flying away
          if (p.userData.flightLife !== undefined) {
            const now = performance.now();
            const last = p.userData.lastTrailTime || 0;
            if (now - last > 50) { // throttle
              const dir = Math.sign(p.userData.kb.x || (p === leftPlayer ? 1 : -1)) || 1;
              spawnDamageTrail(p, dir, p === leftPlayer ? "left" : "right");
              p.userData.lastTrailTime = now;
            }
          }
          if (p.position.y <= baseY) {
            p.position.y = baseY;
            p.userData.kb.y = 0;
          }
          if (p.userData.flightLife !== undefined) {
            p.userData.flightLife -= delta;
            flightActive = true;
            if (p.userData.flightLife <= 0 && p.visible) {
              spawnSplash(p);
              p.visible = false;
              p.userData.kb = null;
              p.userData.knock = null;
              p.userData.flightLife = null;
              followTarget = null;
              if (state.pendingCelebrate) triggerCelebrate();
            }
          }
        } else {
          const t = performance.now() * 0.001;
          const idleBob = Math.sin(t * 2) * 0.08;
          p.rotation.y = THREE.MathUtils.lerp(p.rotation.y, 0, delta * 3);
          p.position.x = THREE.MathUtils.lerp(p.position.x, p.userData.targetX, delta * 3);
          p.position.y = THREE.MathUtils.lerp(p.position.y, baseY + idleBob, delta * 4);
        }
        updateEyes(p, delta);
      });
      if (followTarget && followTarget.visible) {
        camFocusTargetX = followTarget.position.x;
        camDistTarget = 14;
      } else if (state.pendingCelebrate && !flightActive) {
        triggerCelebrate();
      }
      updateChargeOrbs(leftPlayer, state.charges.left);
      updateChargeOrbs(rightPlayer, state.charges.right);

      // bullet vs bullet (skip unstoppable)
      for (let i = 0; i < bullets.length; i++) {
        for (let j = i + 1; j < bullets.length; j++) {
          const a = bullets[i], b = bullets[j];
          if (!a || !b) continue;
          if (a.userData.fromLeft === b.userData.fromLeft) continue;
          if (a.userData.unstoppable || b.userData.unstoppable) continue;
          if (a.position.distanceTo(b.position) < 0.45) {
            if (a.userData?.outline) scene.remove(a.userData.outline);
            if (b.userData?.outline) scene.remove(b.userData.outline);
            scene.remove(a); scene.remove(b);
            bullets.splice(j, 1); bullets.splice(i, 1);
            i = -1; break;
          }
        }
      }

      for (let i = bullets.length - 1; i >= 0; i--) {
        const b = bullets[i];
        b.position.x += b.userData.dir * delta * 8;
        if (b.userData.upVel !== undefined) {
          b.position.y += b.userData.upVel * delta;
          b.userData.upVel -= (b.userData.gravity || 10) * delta;
        }
        if (b.userData.outline) b.userData.outline.position.copy(b.position);
        b.userData.life -= delta;
        const target = b.userData.target;
        if (target) {
            const targetPos = target.position.clone();
            targetPos.y = 1.1;
            targetPos.z = 0;
            const dist = b.position.distanceTo(targetPos);
            if (dist <= 0.55) {
              if (isShieldActive(target)) {
                reflectBullet(b, target);
                continue;
              }
              if (b.userData.willHit) {
                // Remember hit direction for hat knock-off
                target.userData.lastHitDir = b.userData.dir || (b.userData.fromLeft ? 1 : -1);
                if (sounds.hit) { sounds.hit.currentTime = 0; sounds.hit.play(); }
                spawnSplash(target);
                addStain(target);
                knockBack(target, b.userData.dir);
                knockOffHeadgear(target, target === leftPlayer ? "left" : "right", target === leftPlayer ? state.headgear.left : state.headgear.right);
        spawnDamageTrail(target, b.userData.dir || (b.userData.fromLeft ? 1 : -1), target === leftPlayer ? "left" : "right");
                spawnImpactAtWorld(targetPos);
                spawnScreenFlash();
                hitFreezeTimer = 0.25;
              }
              if (b.userData.outline) scene.remove(b.userData.outline);
              scene.remove(b);
              bullets.splice(i, 1);
              continue;
            }
          }
        if (b.userData.life <= 0) {
          if (b.userData.outline) scene.remove(b.userData.outline);
          scene.remove(b);
          bullets.splice(i, 1);
        }
      }

      for (let i = splashes.length - 1; i >= 0; i--) {
        const p = splashes[i];
        p.position.add(p.userData.vel.clone().multiplyScalar(delta));
        p.userData.vel.y -= delta * 3.2;
        p.userData.life -= delta;
        if (p.userData.life <= 0) {
          scene.remove(p);
          splashes.splice(i, 1);
        }
      }

      for (let i = rains.length - 1; i >= 0; i--) {
        const r = rains[i];
        r.position.y += r.userData.velY * delta * 4;
        if (r.userData.pull) {
          r.position.x += r.userData.pull.x * delta;
          r.position.y += r.userData.pull.y * delta;
          r.position.z += r.userData.pull.z * delta;
        }
        r.userData.life -= delta;
        if (r.position.y <= -1.2) r.userData.life = Math.min(r.userData.life, 0.9);
        if (r.userData.life <= 0) {
          scene.remove(r);
          rains.splice(i, 1);
        }
      }

      for (let i = guards.length - 1; i >= 0; i--) {
        const g = guards[i];
        g.userData.life -= delta;
        g.userData.scale += delta * 2;
        g.scale.setScalar(g.userData.scale);
        g.material.opacity = Math.max(0, g.userData.life);
        if (g.userData.life <= 0) {
          scene.remove(g);
          guards.splice(i, 1);
        }
      }
      for (let i = knockedHats.length - 1; i >= 0; i--) {
        const hat = knockedHats[i];
        // Fly fast then remove when life expires
        hat.position.add(hat.userData.vel.clone().multiplyScalar(delta));
        hat.userData.vel.y -= hat.userData.gravity * delta;
        hat.rotation.x += hat.userData.spin.x * delta;
        hat.rotation.y += hat.userData.spin.y * delta;
        hat.rotation.z += hat.userData.spin.z * delta;
        hat.userData.life -= delta;
        if (hat.userData.life <= 0 || Math.abs(hat.position.y) > 50) {
          scene.remove(hat);
          knockedHats.splice(i, 1);
        }
      }
      for (let i = stars.length - 1; i >= 0; i--) {
        const s = stars[i];
        s.position.add(s.userData.vel.clone().multiplyScalar(delta));
        s.userData.vel.y -= 10 * delta;
        s.rotation.x += s.userData.spin.x * delta;
        s.rotation.y += s.userData.spin.y * delta;
        s.rotation.z += s.userData.spin.z * delta;
        s.userData.life -= delta;
        s.material.opacity = Math.max(0, s.userData.life / s.userData.start);
        if (s.userData.life <= 0) {
          scene.remove(s);
          stars.splice(i, 1);
        }
      }
      for (let i = honeycombs.length - 1; i >= 0; i--) {
        const h = honeycombs[i];
        h.position.add(h.userData.vel.clone().multiplyScalar(delta));
        h.rotation.x += h.userData.spin.x * delta;
        h.rotation.y += h.userData.spin.y * delta;
        h.rotation.z += h.userData.spin.z * delta;
        h.userData.life -= delta;
        h.material.opacity = Math.max(0, h.userData.life / h.userData.start);
        if (h.userData.life <= 0) {
          scene.remove(h);
          honeycombs.splice(i, 1);
        }
      }
      for (let i = streaks.length - 1; i >= 0; i--) {
        const st = streaks[i];
        st.userData.life -= delta;
        st.material.opacity = Math.max(0, st.userData.life / st.userData.start);
        if (st.userData.life <= 0) {
          scene.remove(st);
          streaks.splice(i, 1);
        }
      }
      for (let i = chargeGlows.length - 1; i >= 0; i--) {
        const g = chargeGlows[i];
        g.userData.t = (g.userData.t || 0) + delta * 1.5;
        const t = g.userData.t;
        g.scale.setScalar(1 + Math.sin(t * 4) * 0.1);
        const hue = (t * 120) % 360;
        g.material.color.setHSL(hue / 360, 1, 0.6);
        g.material.opacity = Math.max(0, 0.6 - t * 0.6);
        if (g.userData.life !== undefined) {
          g.userData.life -= delta;
          if (g.userData.life <= 0) {
            if (g.parent) g.parent.remove(g);
            scene.remove(g);
            chargeGlows.splice(i, 1);
          }
        }
      }
      for (let i = damageTrails.length - 1; i >= 0; i--) {
        const d = damageTrails[i];
        d.userData.life -= delta;
        d.material.opacity = Math.max(0, d.userData.life / d.userData.start);
        if (d.userData.life <= 0) {
          if (d.geometry) d.geometry.dispose();
          if (d.material) d.material.dispose();
          scene.remove(d);
          damageTrails.splice(i, 1);
        }
      }
      for (let i = barriers.length - 1; i >= 0; i--) {
        const b = barriers[i];
        b.userData.life -= delta;
        b.material.opacity = Math.max(0, b.userData.life / b.userData.start);
        b.scale.setScalar(1 + (1 - b.userData.life / b.userData.start) * 0.3);
        if (b.userData.life <= 0) {
          scene.remove(b);
          barriers.splice(i, 1);
        }
      }
      for (let i = confettis.length - 1; i >= 0; i--) {
        const c = confettis[i];
        if (c.userData.vel) {
          c.position.add(c.userData.vel.clone().multiplyScalar(delta));
          c.userData.vel.y -= 3 * delta;
        }
        c.rotation.x += 3 * delta;
        c.rotation.y += 2 * delta;
        c.userData.life -= delta;
        c.material.opacity = Math.max(0, c.userData.life / c.userData.start);
        if (c.userData.life <= 0) {
          scene.remove(c);
          confettis.splice(i, 1);
        }
      }
      updateHandLines();
      updateShieldMeters();
      updateBoostUI();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      debugCanvas.width = window.innerWidth;
      debugCanvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
